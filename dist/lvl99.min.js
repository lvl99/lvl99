!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("jQuery")):"function"==typeof define&&define.amd?define(["jQuery"],n):"object"==typeof exports?exports.lvl99=n(require("jQuery")):e.lvl99=n(e.jQuery)}(window,function(__WEBPACK_EXTERNAL_MODULE_jquery__){return function(e){function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},n.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s="./es6/index.es6")}({"./es6/common.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.events = exports.$body = exports.$html = exports.$win = exports.$doc = exports.$ = undefined;\n\nvar _jquery = __webpack_require__(/*! jquery */ \"jquery\");\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar $ = exports.$ = _jquery2.default;\n\n/**\n * Basic shorthand props to cache/reference common jQuery objects\n */\n/**\n * LVL99 Common\n *\n * Common dependencies and other useful things\n *\n * @package lvl99\n */\n\nvar $doc = exports.$doc = $(document);\nvar $win = exports.$win = $(window);\nvar $html = exports.$html = $('html');\nvar $body = exports.$body = $('body');\n\n/**\n * Event name shorthands\n */\nvar events = exports.events = {\n  click: 'click touchend',\n  inputstart: 'mousedown touchstart keydown',\n  inputend: 'mouseup touchend keyup',\n  animationrun: 'animationrun webkitAnimationRun webkitanimationrun mozAnimationRun MSAnimationRun oAnimationRun oanimationrun',\n  animationstart: 'animationstart webkitAnimationStart webkitanimationstart mozAnimationStart MSAnimationStart oAnimationStart oanimationstart',\n  animationend: 'animationend webkitAnimationEnd webkitanimationend mozAnimationEnd MSAnimationEnd oAnimationEnd oanimationend',\n  transitionrun: 'transitionrun webkitTransitionRun webkittransitionrun mozTransitionRun MSTransitionRun oTransitionRun otransitionrun',\n  transitionstart: 'transitionstart webkitTransitionStart webkittransitionstart mozTransitionStart MSTransitionStart oTransitionStart otransitionstart',\n  transitionend: 'transitionend webkitTransitionEnd webkittransitionend mozTransitionEnd MSTransitionEnd oTransitionEnd otransitionend'\n};\n\nvar utils = {\n  $: $,\n  $doc: $doc,\n  $win: $win,\n  $html: $html,\n  $body: $body,\n  events: events\n};\n\nexports.default = utils;\n\n//# sourceURL=webpack://lvl99/./es6/common.es6?")},"./es6/core/app.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _uuid = __webpack_require__(/*! uuid */ \"./node_modules/uuid/index.js\");\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _entity = __webpack_require__(/*! ./entity */ \"./es6/core/entity.es6\");\n\nvar _entity2 = _interopRequireDefault(_entity);\n\nvar _common = __webpack_require__(/*! ../common */ \"./es6/common.es6\");\n\nvar _parse = __webpack_require__(/*! ../utils/parse */ \"./es6/utils/parse.es6\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * LVL99 App\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package lvl99\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n/**\n * Get a component's namespace\n *\n * @private\n * @param {Component} component\n * @returns {undefined|String|Component}\n */\nfunction getComponentNamespace(component) {\n  var componentNS = component;\n\n  // Function/class given\n  if (typeof component === 'function') {\n    if (component.NS) {\n      componentNS = component.NS;\n    } else {\n      componentNS = component.prototype.constructor.name;\n    }\n  }\n\n  return componentNS;\n}\n\n/**\n * The App's base properties\n *\n * @private\n * @type {Object}\n */\nvar AppProperties = {\n  /**\n   * NAMESPACE\n   * This is used for custom events and error reporting\n   *\n   * @type {String}\n   */\n  _NS: 'LVL99:App',\n\n  /**\n   * namespace\n   * This is used for CSS classes\n   *\n   * @type {String}\n   */\n  _ns: 'lvl99-app',\n\n  /**\n   * The properties shared between all instances of this App\n   *\n   * @type {Object}\n   */\n  _properties: {},\n\n  /**\n   * The default attributes to load a created App instance with.\n   *\n   * @type {Object}\n   */\n  _attributes: {},\n\n  /**\n   * The library of components that the app has access to\n   *\n   * @type {Object}\n   */\n  _components: {},\n\n  /**\n   * The collection of components which have been instantiated within the app\n   *\n   * @type {Object}\n   */\n  _componentInstances: {}\n\n  /**\n   * App\n   *\n   * @class\n   * @extends Entity\n   */\n};\nvar App = function (_Entity) {\n  _inherits(App, _Entity);\n\n  /**\n   * App constructor\n   *\n   * @constructor\n   * @param {Object} attributes\n   */\n  function App(attributes) {\n    _classCallCheck(this, App);\n\n    // @debug\n    // console.log(`LVL99:App:constructor`)\n\n    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, attributes));\n  }\n\n  /**\n   * Extend the App with any given {Object} arguments\n   */\n\n\n  _createClass(App, [{\n    key: 'extend',\n    value: function extend() {\n      var _get2;\n\n      // @debug\n      // console.log(`LVL99:App:extend`, ...arguments)\n\n      // Merge the properties with the instantiated attributes\n      (_get2 = _get(App.prototype.__proto__ || Object.getPrototypeOf(App.prototype), 'extend', this)).call.apply(_get2, [this, AppProperties].concat(Array.prototype.slice.call(arguments)));\n    }\n\n    /**\n     * Register a component class in the app. You can also specify a separate namespace to register it under.\n     *\n     * @param {Component} componentClass\n     * @param {String} componentClassNamespace\n     */\n\n  }, {\n    key: 'registerComponentClass',\n    value: function registerComponentClass(componentClass, componentClassNamespace) {\n      var componentClassNS = void 0;\n\n      // No valid componentClass given\n      if (!componentClass) {\n        throw new Error('No component class was given');\n      }\n\n      // Get the namespace from the component class (or otherwise specified)\n      componentClassNS = getComponentNamespace(componentClassNamespace || componentClass);\n\n      // Register the component class\n      if (componentClassNS) {\n        this._components[componentClassNS] = componentClass;\n      }\n    }\n\n    /**\n     * Deregister a component class by namespace\n     *\n     * @param {String|Component} componentClassNamespace\n     */\n\n  }, {\n    key: 'deregisterComponentClass',\n    value: function deregisterComponentClass(componentClassNamespace) {\n      var componentClassNS = void 0;\n\n      // No valid componentClass given\n      if (!componentClassNamespace) {\n        throw new Error('No component class namespace was given');\n      }\n\n      // Get the namespace\n      componentClassNS = getComponentNamespace(componentClassNamespace);\n\n      // Remove the component class\n      if (componentClassNS && this._components.hasOwnProperty(componentClassNS)) {\n        this._components[componentClassNS] = undefined;\n        delete this._components[componentClassNS];\n      }\n    }\n\n    /**\n     * Get a component class by namespace\n     *\n     * @param {String} componentClassNamespace\n     * @return {undefined|Component}\n     */\n\n  }, {\n    key: 'getComponentClass',\n    value: function getComponentClass(componentClassNamespace) {\n      var componentClassNS = componentClassNamespace;\n\n      if (!componentClassNamespace) {\n        throw new Error('No component class namespace was given');\n      }\n\n      // Get the component class\n      if (componentClassNS && this._components.hasOwnProperty(componentClassNS)) {\n        return this._components[componentClassNS];\n      }\n\n      return undefined;\n    }\n\n    /**\n     * Add component instance to app and initialise the component instance\n     *\n     * @param {Component} componentInstance\n     */\n\n  }, {\n    key: 'addComponentInstance',\n    value: function addComponentInstance(componentInstance) {\n      componentInstance._app = this;\n\n      // Add component instance to collection\n      this._componentInstances[componentInstance.uuid] = componentInstance;\n\n      // Initialise the component\n      componentInstance.init();\n    }\n\n    /**\n     * Create component instance\n     *\n     * @param {String} componentClassNamespace\n     * @param {Object} attributes\n     * @returns {Component}\n     */\n\n  }, {\n    key: 'createComponentInstance',\n    value: function createComponentInstance(componentClassNamespace, attributes) {\n      // @debug\n      // console.log(`${this.NS}.createComponentInstance: ${componentClassNamespace}`)\n\n      // Create and initialise the component\n      if (this._components.hasOwnProperty(componentClassNamespace)) {\n        var newComponent = new this._components[componentClassNamespace](attributes);\n\n        // @debug\n        // console.log(`${this.NS}.createComponentInstance`, {\n        //   componentClassNamespace,\n        //   newComponent,\n        //   attributes\n        // })\n\n        // Add instance to app\n        this.addComponentInstance(newComponent);\n\n        return newComponent;\n      }\n    }\n\n    /**\n     * Get a component instance by UUID\n     *\n     * @param {String} componentUUID\n     * @returns {undefined|Component}\n     */\n\n  }, {\n    key: 'getComponentInstance',\n    value: function getComponentInstance(componentUUID) {\n      // @debug\n      // console.log(`${this.NS}.getComponentInstance: ${componentUUID}`)\n\n      if (this._componentInstances.hasOwnProperty(componentUUID)) {\n        return this._componentInstances[componentUUID];\n      }\n\n      return undefined;\n    }\n\n    /**\n     * Remove component instance by UUID\n     *\n     * @param {Component} componentUUID\n     */\n\n  }, {\n    key: 'removeComponentInstance',\n    value: function removeComponentInstance(componentUUID) {\n      // @debug\n      // console.log(`${this.NS}.removeComponentInstance: ${componentUUID}`)\n\n      var removeComponentInstance = this.getComponentInstance(componentUUID);\n      if (typeof removeComponentInstance !== 'undefined') {\n        // @debug\n        // console.log(`${this.NS}.removeComponentInstance: found component instance to remove`, removeComponentInstance)\n\n        removeComponentInstance.destroy();\n\n        // @TODO the following should probably only happen after a Promise is resolved\n        // Remove entry in the componentInstances object\n        this._componentInstances[componentUUID] = undefined;\n        delete this._componentInstances[componentUUID];\n      }\n    }\n\n    /**\n     * Initialise any component which is marked in the DOM\n     */\n\n  }, {\n    key: 'initialiseComponents',\n    value: function initialiseComponents() {\n      var _this2 = this;\n\n      // Find any element marked with the `[data-component]` attribute\n      (0, _common.$)('[data-component]')\n      // Ignore components which already have an ID assigned\n      .not('[data-component-id]')\n      // Initialise each component\n      .each(function (index, elem) {\n        var $elem = (0, _common.$)(elem);\n        var elemComponentClass = $elem.attr('data-component');\n        var elemComponentOptions = $elem.attr('data-component-options') || {};\n\n        // @debug\n        // console.log(`${this._NS}.initialiseComponents: found element to initialise with component`, {\n        //   index,\n        //   elem,\n        //   elemComponentClass,\n        //   elemComponentOptions\n        // })\n\n        // Ensure component class is registered\n        if (!_this2.getComponentClass(elemComponentClass)) {\n          // @debug\n          // console.error(`${this._NS}.initialiseComponents: element's component class not registered`, {\n          //   app: this,\n          //   index,\n          //   elem,\n          //   elemComponentClass,\n          //   elemComponentOptions\n          // })\n          return;\n        }\n\n        // Extract/convert the options\n        if (typeof elemComponentOptions === 'string') {\n          // Set as JSON, e.g. '{\"name\":\"value\"}`\n          if (/^\\{/.test(elemComponentOptions)) {\n            elemComponentOptions = (0, _parse.convertStringToJson)(elemComponentOptions);\n\n            // Set as style-like attributes, e.g. `name: value; name: value`\n          } else {\n            elemComponentOptions = (0, _parse.extractClassDetails)(elemComponentOptions);\n          }\n        }\n\n        // Add the $elem if it is not already set\n        if (!elemComponentOptions.hasOwnProperty('$elem')) {\n          elemComponentOptions.$elem = $elem;\n        }\n\n        // Create the component\n        var elemComponentInstance = _this2.createComponentInstance(elemComponentClass, elemComponentOptions);\n\n        // @debug\n        // console.log('Initialised component instance', {\n        //   index,\n        //   elem,\n        //   elemComponentOptions,\n        //   elemComponentInstance\n        // })\n      });\n    }\n  }]);\n\n  return App;\n}(_entity2.default);\n\nexports.default = App;\n\n//# sourceURL=webpack://lvl99/./es6/core/app.es6?")},"./es6/core/component.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _objectPath = __webpack_require__(/*! object-path */ \"./node_modules/object-path/index.js\");\n\nvar _objectPath2 = _interopRequireDefault(_objectPath);\n\nvar _lodash = __webpack_require__(/*! lodash.merge */ \"./node_modules/lodash.merge/index.js\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _entity = __webpack_require__(/*! ./entity */ \"./es6/core/entity.es6\");\n\nvar _entity2 = _interopRequireDefault(_entity);\n\nvar _common = __webpack_require__(/*! ../common */ \"./es6/common.es6\");\n\nvar _parse = __webpack_require__(/*! ../utils/parse */ \"./es6/utils/parse.es6\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * LVL99 Component\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @package lvl99\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n// import { wrap } from '../utils/super'\n\n\n// Track components and whether they have been initialised and public methods added, etc.\nvar trackComponents = {};\n\n/**\n * The Component's base properties\n *\n * @type {Object}\n */\nvar ComponentProperties = {\n  /**\n   * NAMESPACE\n   * This is used for custom events and error reporting\n   *\n   * @type {String}\n   * @default LVL99\n   */\n  _NS: 'LVL99:Component',\n\n  /**\n   * namespace\n   * This is used for CSS classes\n   *\n   * @type {String}\n   * @default lvl99\n   */\n  _ns: 'lvl99-component',\n\n  /**\n   * The properties shared between all instances of this Component\n   *\n   * @type {Object}\n   */\n  _properties: {\n    /**\n     * The names of Component methods to publicly expose in the DOM via custom events (attached during `init`).\n     *\n     * Each entry can be a string (which will then be a global event; be careful with global events being attached twice),\n     * or can be an object where you specify the target (often 'self') and set what method to do on whatever event, e.g.:\n     *\n     * ```\n     *   // This will trigger the Component's `exampleMethod` when the Component's $elem is targeted/triggered\n     *   // using the automatically generated custom event name:\n     *   // `$elem.trigger('Component:exampleMethod')`\n     *   {\n     *     target: 'self',\n     *     do: 'exampleMethod'\n     *   }\n     *\n     *   // This will trigger the Component's `exampleMethod` when the document is targeted/triggered using a custom\n     *   // event name:\n     *   // `$(document).trigger('customEventName')`\n     *   {\n     *     target: 'document',\n     *     do: 'exampleMethod',\n     *     on: 'customEventName'\n     *   }\n     *\n     *   // This will trigger the Component's `exampleMethod` when the window is scrolled:\n     *   // `$(window).scroll()`\n     *   {\n     *     target: 'window',\n     *     do: 'exampleMethod',\n     *     on: 'scroll'\n     *   }\n     * ```\n     *\n     * @type {Array}\n     */\n    publicMethods: [],\n\n    /**\n     * The target to apply any CSS classes to\n     *\n     * @type {jQueryObject}\n     */\n    $classTarget: undefined\n  },\n\n  /**\n   * The default attributes to load a created Component instance with.\n   *\n   * @type {Object}\n   */\n  _attributes: {\n    /**\n     * The main element that represents the Component in the DOM. Component events will be managed through this element.\n     */\n    $elem: undefined\n  }\n\n  /**\n   * Component\n   *\n   * @class\n   * @extends Entity\n   */\n};\nvar Component = function (_Entity) {\n  _inherits(Component, _Entity);\n\n  /**\n   * Component constructor\n   *\n   * @constructor\n   * @param {Object} attributes\n   */\n  function Component(attributes) {\n    _classCallCheck(this, Component);\n\n    // @debug\n    // console.log('LVL99:Component:constructor', {\n    //   arguments\n    // })\n\n    return _possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this, attributes));\n  }\n\n  /**\n   * Extend the Component's properties with any {Object} arguments\n   */\n\n\n  _createClass(Component, [{\n    key: 'extend',\n    value: function extend() {\n      var _get2;\n\n      // @debug\n      // console.log('LVL99:Component:extend', {\n      //   arguments\n      // })\n\n      // Concat all the publicMethods into one array (since merge doesn't do that with plain arrays)\n      var args = [].concat(Array.prototype.slice.call(arguments));\n      var allPublicMethods = ComponentProperties._properties.publicMethods.slice(0);\n      args.forEach(function (arg) {\n        var hasPublicMethods = _objectPath2.default.get(arg, '_properties.publicMethods');\n        if (hasPublicMethods && hasPublicMethods instanceof Array) {\n          allPublicMethods = allPublicMethods.concat(hasPublicMethods);\n        }\n      });\n      allPublicMethods = Array.from(new Set(allPublicMethods));\n\n      // Extend the component's properties with the instantiated attributes and concatenated public methods\n      (_get2 = _get(Component.prototype.__proto__ || Object.getPrototypeOf(Component.prototype), 'extend', this)).call.apply(_get2, [this, ComponentProperties].concat(_toConsumableArray(args), [{\n        _properties: {\n          publicMethods: allPublicMethods\n        }\n      }]));\n    }\n\n    /**\n     * Get the component's element\n     *\n     * @return {undefined|jQueryObject}\n     */\n\n  }, {\n    key: 'getElem',\n    value: function getElem() {\n      // Soft return\n      if (!this.getAttr('elem') && (!this.getAttr('$elem') || !this.getAttr('$elem').length)) {\n        console.warn(this.NS + '.getElem: no elem was found for this component. This may cause problems with components which rely on the elem attribute.');\n        return undefined;\n      }\n\n      // Elem (or $elem) is set to string\n      if (typeof this.getAttr('elem') === 'string' || typeof this.getAttr('$elem') === 'string') {\n        var $elem = (0, _common.$)(this.getAttr('elem'));\n        if ($elem.length) {\n          this.setAttr('elem', $elem[0]);\n          this.setAttr('$elem', $elem);\n        }\n      }\n\n      // Get & set the element\n      if (this.getAttr('elem') && !this.getAttr('$elem')) {\n        this.setAttr((0, _common.$)(this.getAttr('elem')));\n      }\n\n      return this.getAttr('$elem');\n    }\n\n    /**\n     * Mark the Component's element with necessary attributes\n     */\n\n  }, {\n    key: 'markElem',\n    value: function markElem() {\n      // Mark the element\n      if (this.getElem() && this.getElem().length) {\n        if (!this.getElem().attr('data-component')) {\n          this.getElem().attr('data-component', this.NS);\n        }\n\n        if (!this.getElem().attr('data-component-id')) {\n          this.getElem().attr('data-component-id', this.uuid);\n        }\n\n        this.triggerEvent('markElem:end');\n      }\n    }\n\n    /**\n     * Get the target to apply the CSS state classes to\n     *\n     * @return {undefined|jQueryObject}\n     */\n\n  }, {\n    key: 'getClassTarget',\n    value: function getClassTarget() {\n      // Prioritise attr\n      var $classTarget = this.getAttr('$classTarget');\n\n      // Not found in attr? Use prop\n      if (!$classTarget || !$classTarget.length) {\n        $classTarget = this.getProp('$classTarget');\n      }\n\n      // Not found in prop? Use elem\n      if (!$classTarget || !$classTarget.length) {\n        $classTarget = this.getElem();\n\n        // Ensure set as attr\n        this.setAttr('$classTarget', $classTarget);\n      }\n\n      return $classTarget;\n    }\n\n    /**\n     * Get the attributes from the DOM element and place into the Component instance\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'loadAttrs',\n    value: function loadAttrs() {\n      if (this.getElem() && this.getElem().is('[data-component-attributes]')) {\n        var attrs = {};\n\n        // Attempt to get the attributes from the DOM element\n        try {\n          attrs = JSON.parse(this.getElem().attr('data-component-attributes'));\n        } catch (e) {\n          console.error('[' + this.NS + '] loadAttrs: Error loading attributes from DOM element');\n        }\n\n        this._attributes = (0, _lodash2.default)(this._attributes, attrs);\n\n        // Once loaded, remove the component attributes from the DOM\n        this.getElem().removeAttr('data-component-attributes');\n\n        return this._attributes;\n      }\n    }\n\n    /**\n     * Initialise Component\n     */\n\n  }, {\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      _get(Component.prototype.__proto__ || Object.getPrototypeOf(Component.prototype), 'init', this).apply(this, arguments);\n\n      // @debug\n      // console.log(`[${this.NS:init}]`)\n\n      // Track that the component has been initialised\n      if (!trackComponents.hasOwnProperty(this.NS)) {\n        trackComponents[this.NS] = {\n          instances: _defineProperty({}, '' + this.uuid, this)\n        };\n      } else {\n        trackComponents[this.NS].instances['' + this.uuid] = this;\n      }\n\n      // @debug\n      // console.log(trackComponents)\n\n      // Mark the element\n      this.markElem();\n\n      /**\n       * Attach Component's public methods to targets\n       * Public methods can be triggered on the targets via `$(target).trigger('NAMESPACE:publicMethodName')`\n       */\n      var publicMethods = this.getProp('publicMethods');\n      if (publicMethods && publicMethods.length) {\n        publicMethods.forEach(function (trigger) {\n          var triggerDetails = {};\n\n          // Already object\n          if ((typeof trigger === 'undefined' ? 'undefined' : _typeof(trigger)) === 'object') {\n            triggerDetails = trigger;\n          } else if (typeof trigger === 'string') {\n            if (/^{/.test(trigger) || /[:;]/.test(trigger)) {\n              triggerDetails = (0, _parse.extractTriggerDetails)(trigger);\n            } else {\n              triggerDetails.do = trigger;\n            }\n          }\n\n          // If empty, set `on` to `do` value (consider it a custom event to invoke, e.g. 'init' would invoke 'init' on this Component)\n          if (!_objectPath2.default.has(triggerDetails, 'on')) {\n            triggerDetails.on = triggerDetails.do;\n          }\n\n          // Context should always be this Component\n          triggerDetails.context = _this2;\n\n          // Get the Component's method\n          var method = undefined;\n          try {\n            method = triggerDetails.context[triggerDetails.do];\n          } catch (e) {\n            throw new Error('[' + _this2.NS + '] init: public method \\'' + triggerDetails.do + '\\' was not found on this component');\n          }\n\n          // @debug\n          // console.log(`[${this.NS}] init: public method \"${triggerDetails.do}\"`, {\n          //   triggerDetails,\n          //   method\n          // })\n\n          // Only attach public method if it hasn't been attached already or has a target\n          if (!triggerDetails.hasOwnProperty('target') && Object.keys(trackComponents[_this2.NS].instances).length > 1) {\n            // @debug\n            // console.warn(`[${this.NS}] init: public method ${this.NS}:${triggerDetails.do} already assigned. Skipping...`)\n            return;\n          }\n\n          // Attach the method as a custom event to the target\n          if (typeof method === 'function') {\n            // Wrap the method into a closure\n            var doComponentMethod = function doComponentMethod(jQueryEvent) {\n              // @debug\n              // console.log(`Triggered ${this.NS}:${triggerDetails.do}`, {\n              //   _class: this,\n              //   _method: method,\n              //   jQueryEvent,\n              //   args: arguments\n              // })\n\n              method.call(_this2, jQueryEvent);\n            };\n\n            // Attach to the target document with a particular element selector\n            if (triggerDetails.selector) {\n              _this2.bindEventToTargetSelector(triggerDetails.on, triggerDetails.selector, doComponentMethod, triggerDetails.target);\n\n              // Attach to the target\n            } else {\n              _this2.bindEventToTarget(triggerDetails.on, doComponentMethod, triggerDetails.target);\n            }\n\n            // Error\n          } else {\n            // @debug\n            // console.log(this, trigger, triggerDetails)\n            throw new Error('[' + _this2.NS + '] init: public method \\'' + triggerDetails.do + '\\' is not a valid function');\n          }\n        });\n      }\n\n      /**\n       * Load any attributes that were attached to the DOM element\n       */\n      this.loadAttrs();\n\n      /**\n       * @trigger NAMESPACE:init:end\n       * @param {Component}\n       */\n      this.triggerEvent('init:end');\n    }\n\n    /**\n     * Destroy and tear down the component\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      // @TODO tear down the house!\n      // @TODO remove the bound public events\n      // @TODO other garbage collection/memory management\n\n      /**\n       * @trigger NAMESPACE:destroy:beforeend\n       * @param {Component}\n       */\n      this.triggerEvent('destroy:beforeend');\n\n      _get(Component.prototype.__proto__ || Object.getPrototypeOf(Component.prototype), 'destroy', this).apply(this, arguments);\n    }\n\n    /**\n     * Bind method to custom event on target\n     * Event names are automatically namespaced using the Component's _NS property.\n     * To not use namespaced events, preface with `dom:`\n     *\n     * @param {String} eventName\n     * @param {Function} method\n     * @param {Object} target Default is `document`. This is the target DOM element which the custom event will bubble up to\n     */\n\n  }, {\n    key: 'bindEventToTarget',\n    value: function bindEventToTarget(eventName, method, target) {\n      // Default to document\n      if (!target) {\n        target = document;\n      } else {\n        // Special string values to get the actual object\n        switch (target) {\n          case 'document':\n            target = document;\n            break;\n\n          case 'window':\n            target = window;\n            break;\n\n          case 'self':\n            target = this.getElem()[0];\n            break;\n        }\n      }\n\n      // Extract the target event names from the input given\n      var eventNames = (0, _parse.extractTargetEventNames)(eventName, this.NS);\n\n      // @debug\n      // console.log(`[${this.NS}] bindEventToTarget`, {\n      //   eventName,\n      //   method,\n      //   target,\n      //   triggerName: targetEventNames\n      // })\n\n      // Assign the trigger\n      if (eventNames) {\n        (0, _common.$)(target).on(eventNames.join(' '), method);\n      }\n    }\n\n    /**\n     * Bind method to custom event on target with an element selector.\n     * Event names are automatically namespaced using the Component's _NS property.\n     *\n     * @param {String} eventName\n     * @param {String} selector Target a specific element (via query selector) to trigger the event\n     * @param {Function} method\n     * @param {Object} target Default is `document`. This is the target DOM element which the custom event will bubble up to\n     */\n\n  }, {\n    key: 'bindEventToTargetSelector',\n    value: function bindEventToTargetSelector(eventName, selector, method, target) {\n      target = (0, _parse.getTargetBySelector)(target, this);\n      selector = (0, _parse.getTargetSelector)(selector, this);\n      var eventNames = (0, _parse.extractTargetEventNames)(eventName, this.NS);\n\n      // @debug\n      // console.log(`[${this.NS}] bindEventToTargetSelector`, {\n      //   eventName,\n      //   selector,\n      //   method,\n      //   target,\n      //   triggerName: `${this.NS}:${eventName}`\n      // })\n\n      if (eventNames) {\n        (0, _common.$)(target).on(eventNames.join(' '), selector, method);\n      }\n    }\n\n    /**\n     * Trigger a custom document event on the Component.\n     * The event triggered will be `NAMESPACE:eventName`.\n     *\n     * @param {String} eventName\n     * @param {Any} ...args\n     */\n\n  }, {\n    key: 'triggerEvent',\n    value: function triggerEvent(eventName) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      // @debug\n      // console.log(`[${this.NS}] triggerEvent: ${this.NS}:${eventName}`)\n\n      // Always pass the component as the first argument parameter\n      _common.$doc.trigger(this.NS + ':' + eventName, [this].concat(args));\n    }\n\n    /**\n     * Trigger a custom document event on an element on the Component.\n     * The event triggered will be `NAMESPACE:eventName`.\n     *\n     * @param {String} eventName\n     * @param {String} selector\n     * @param {Any} ...args\n     */\n\n  }, {\n    key: 'triggerEventOnSelector',\n    value: function triggerEventOnSelector(eventName, selector) {\n      selector = (0, _parse.getTargetSelector)(selector, this);\n\n      // @debug\n      // console.log(`[${this.NS}] triggerEventOnSelector: ${this.NS}:${eventName}`)\n\n      // Always pass the component as the first argument parameter\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      (0, _common.$)(selector).trigger(this.NS + ':' + eventName, [this].concat(args));\n    }\n  }]);\n\n  return Component;\n}(_entity2.default);\n\nexports.default = Component;\n\n//# sourceURL=webpack://lvl99/./es6/core/component.es6?")},"./es6/core/entity.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LVL99 Entity\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Base class used for programmable entities within the app, such as components or other such entities that rely on\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * state and lifecycle functions.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package lvl99\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _lodash = __webpack_require__(/*! lodash.merge */ \"./node_modules/lodash.merge/index.js\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _uuid = __webpack_require__(/*! uuid */ \"./node_modules/uuid/index.js\");\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _objectPath = __webpack_require__(/*! object-path */ \"./node_modules/object-path/index.js\");\n\nvar _objectPath2 = _interopRequireDefault(_objectPath);\n\nvar _inheritance = __webpack_require__(/*! ../utils/inheritance */ \"./es6/utils/inheritance.es6\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * The Entity's base properties\n *\n * @type {Object}\n */\nvar EntityProperties = {\n  /**\n   * NAMESPACE\n   * This is used for custom events and error reporting\n   *\n   * @type {String}\n   */\n  _NS: 'LVL99:Entity',\n\n  /**\n   * namespace\n   * This is used for CSS classes (only if the entity has an HTMLElement)\n   *\n   * @type {String}\n   */\n  _ns: 'lvl99-entity',\n\n  /**\n   * The properties shared between all instances of this Entity\n   *\n   * @type {Object}\n   */\n  _properties: {},\n\n  /**\n   * The default attributes to load a created Entity instance with.\n   *\n   * @type {Object}\n   */\n  _attributes: {}\n};\n\nvar Entity = function () {\n  /**\n   * Entity constructor\n   *\n   * @constructor\n   * @param {Object} attributes\n   */\n  function Entity(attributes) {\n    _classCallCheck(this, Entity);\n\n    // @debug\n    // console.log('LVL99:Entity:constructor', {\n    //   attributes\n    // })\n\n    this.extend({\n      _attributes: attributes\n    });\n\n    // Expose private values\n    (0, _inheritance.exposePrivateProperties)(this);\n\n    // Create a unique ID for this Entity\n    Object.defineProperty(this, 'uuid', {\n      value: this.NS + ':' + _uuid2.default.v4(),\n      writable: false,\n      enumerable: true,\n      configurable: false\n    });\n  }\n\n  /**\n   * Extend the Entity with any given {Object} arguments\n   *\n   * @returns {Self}\n   */\n\n\n  _createClass(Entity, [{\n    key: 'extend',\n    value: function extend() {\n      // @debug\n      // console.log('LVL99:Entity:extend', {\n      //   args\n      // })\n\n      // Merge the properties with the instantiated attributes and concatenated public methods\n      _lodash2.default.apply(undefined, [this, EntityProperties].concat(Array.prototype.slice.call(arguments)));\n\n      return this;\n    }\n\n    /**\n     * Get an Entity's property value.\n     *\n     * @param {String} propName\n     * @return {Mixed}\n     */\n\n  }, {\n    key: 'getProp',\n    value: function getProp(propName) {\n      if (!propName || typeof propName !== 'string') {\n        throw new Error('[' + this.NS + '] get: \\'propName\\' value is invalid');\n      }\n\n      return _objectPath2.default.get(this.properties, propName);\n    }\n\n    /**\n     * Set an Entity's property to a value.\n     *\n     * @param {String} propName\n     * @param {Mixed} propValue\n     */\n\n  }, {\n    key: 'setProp',\n    value: function setProp(propName, propValue) {\n      if (!propName || typeof propName !== 'string') {\n        throw new Error('[' + this.NS + '] set: \\'propName\\' value is invalid');\n      }\n\n      return _objectPath2.default.set(this.properties, propName, propValue);\n    }\n\n    /**\n     * Get an Entity's attribute value.\n     *\n     * @param {String} attrName\n     * @return {Mixed}\n     */\n\n  }, {\n    key: 'getAttr',\n    value: function getAttr(attrName) {\n      if (!attrName || typeof attrName !== 'string') {\n        throw new Error('[' + this.NS + '] getAttr: \\'attrName\\' value is invalid');\n      }\n\n      return _objectPath2.default.get(this.attributes, attrName);\n    }\n\n    /**\n     * Set an Entity's property to a value.\n     *\n     * @param {String} attrName\n     * @param {Mixed} attrValue\n     */\n\n  }, {\n    key: 'setAttr',\n    value: function setAttr(attrName, attrValue) {\n      if (!attrName || typeof attrName !== 'string') {\n        throw new Error('[' + this.NS + '] setAttr: \\'attrName\\' value is invalid');\n      }\n\n      return _objectPath2.default.set(this.attributes, attrName, attrValue);\n    }\n\n    /**\n     * Initialise the Entity\n     */\n\n  }, {\n    key: 'init',\n    value: function init() {}\n\n    /**\n     * Destroy and tear down the component\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {}\n  }]);\n\n  return Entity;\n}();\n\nexports.default = Entity;\n\n//# sourceURL=webpack://lvl99/./es6/core/entity.es6?")},"./es6/core/index.es6":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _entity = __webpack_require__(/*! ./entity */ "./es6/core/entity.es6");\n\nvar _entity2 = _interopRequireDefault(_entity);\n\nvar _app = __webpack_require__(/*! ./app */ "./es6/core/app.es6");\n\nvar _app2 = _interopRequireDefault(_app);\n\nvar _component = __webpack_require__(/*! ./component */ "./es6/core/component.es6");\n\nvar _component2 = _interopRequireDefault(_component);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar core = {\n  Entity: _entity2.default,\n  App: _app2.default,\n  Component: _component2.default\n}; /**\n    * LVL99 Core\n    *\n    * Core classes used throughout the framework\n    *\n    * @package lvl99\n    */\n\nexports.default = core;\n\n//# sourceURL=webpack://lvl99/./es6/core/index.es6?')},"./es6/index.es6":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _common = __webpack_require__(/*! ./common */ "./es6/common.es6");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _utils = __webpack_require__(/*! ./utils */ "./es6/utils/index.es6");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _core = __webpack_require__(/*! ./core */ "./es6/core/index.es6");\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _tools = __webpack_require__(/*! ./tools */ "./es6/tools/index.es6");\n\nvar _tools2 = _interopRequireDefault(_tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * LVL99\n *\n * The whole framework in one discrete package\n *\n * @package lvl99\n */\n\nvar lvl99 = {\n  common: _common2.default,\n  core: _core2.default,\n  utils: _utils2.default,\n  tools: _tools2.default\n};\n\nexports.default = lvl99;\n\n//# sourceURL=webpack://lvl99/./es6/index.es6?')},"./es6/tools/breakpoints.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Breakpoints;\n/**\n * LVL99 Breakpoints\n * Detect via JS what the breakpoint is by keyword\n *\n * @package lvl99\n */\n\nfunction Breakpoints(sizes) {\n  return {\n    /**\n     * The defined breakpoint names with min/max widths (in 72dpi pixels)\n     * Should coincide with CSS for optimum expected behaviour\n     *\n     * @property sizes\n     * @type {Object} => {Array} [0 = {Number} minWidth, 1 = {Number} maxWidth]\n     */\n    sizes: sizes || {\n      'xs': [0, 399],\n      'mobile': [0, 799],\n      'ms': [400, 599],\n      's': [600, 799],\n      'm': [800, 999],\n      'tablet': [800, 1199],\n      'l': [1000, 1199],\n      'laptop': [1000, 1399],\n      'computer': [1000, 99999],\n      'xl': [1200, 1399],\n      'desktop': [1200, 99999],\n      'xxl': [1400, 99999]\n    },\n\n    /**\n     * Get a string of the currently active breakpoints\n     * @method getActive\n     * @returns {Array}\n     */\n    getActive: function getActive() {\n      var width = window.innerWidth;\n      var bp = [];\n\n      for (var x in this.sizes) {\n        if (this.sizes.hasOwnProperty(x) && width >= this.sizes[x][0] && width <= this.sizes[x][1]) {\n          bp.push(x);\n        }\n      }\n\n      return bp;\n    },\n\n\n    /**\n     * Check if a breakpoint keyword is currently active\n     * @method isActive\n     * @returns {Boolean}\n     */\n    isActive: function isActive(input) {\n      if (input instanceof Array) {\n        input = input.join('|');\n      }\n\n      if (typeof input === 'string') {\n        input = new RegExp('\\\\b(?:' + input.replace(/[\\s,]+/g, '|') + ')\\\\b', 'i');\n      }\n\n      return input.test(this.getActive() + '');\n    }\n  };\n}\n\n//# sourceURL=webpack://lvl99/./es6/tools/breakpoints.es6?")},"./es6/tools/debug.es6":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = Debug;\n/**\n * LVL99 Debug\n *\n * A console-like replacement which creates a noop console object if you don\'t want to output stuff via the console\n *\n * @package lvl99\n */\n\nfunction noop() {}\n\n/**\n * Debug\n *\n * @param {Boolean} silent Set to true to make the console behaviours silent\n * @constructor\n */\nfunction Debug() {\n  var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (silent) {\n    return {\n      clear: noop,\n      count: noop,\n      debug: noop,\n      error: noop,\n      group: noop,\n      info: noop,\n      log: noop,\n      table: noop,\n      time: noop,\n      timeEnd: noop,\n      trace: noop,\n      warn: noop\n    };\n  } else {\n    return console || window.console;\n  }\n}\n\n//# sourceURL=webpack://lvl99/./es6/tools/debug.es6?')},"./es6/tools/index.es6":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _breakpoints = __webpack_require__(/*! ./breakpoints */ "./es6/tools/breakpoints.es6");\n\nvar _breakpoints2 = _interopRequireDefault(_breakpoints);\n\nvar _debug = __webpack_require__(/*! ./debug */ "./es6/tools/debug.es6");\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _queue = __webpack_require__(/*! ./queue */ "./es6/tools/queue.es6");\n\nvar _queue2 = _interopRequireDefault(_queue);\n\nvar _trackevent = __webpack_require__(/*! ./trackevent */ "./es6/tools/trackevent.es6");\n\nvar _trackevent2 = _interopRequireDefault(_trackevent);\n\nvar _smoothScroll = __webpack_require__(/*! ./smooth-scroll */ "./es6/tools/smooth-scroll.es6");\n\nvar _smoothScroll2 = _interopRequireDefault(_smoothScroll);\n\nvar _storage = __webpack_require__(/*! ./storage */ "./es6/tools/storage.es6");\n\nvar _storage2 = _interopRequireDefault(_storage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * LVL99 Tools\n *\n * Standalone tools that don\'t require any dependencies within the framework, but work alongside\n */\n\nvar utils = {\n  Breakpoints: _breakpoints2.default,\n  Debug: _debug2.default,\n  Queue: _queue2.default,\n  TrackEvent: _trackevent2.default,\n  SmoothScroll: _smoothScroll2.default,\n  Storage: _storage2.default\n};\n\nexports.default = tools;\n\n//# sourceURL=webpack://lvl99/./es6/tools/index.es6?')},"./es6/tools/queue.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Queue;\n\nvar _lodash = __webpack_require__(/*! lodash.merge */ \"./node_modules/lodash.merge/index.js\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * # Queue\n *\n * Batch actions into a debounced queue. Useful to reduce amount of work computer/browser does.\n */\n\nvar __loggerPath = 'Queue';\n\n\n/**\n * Queue class\n *\n * @return {Object}\n * @constructor\n */\nfunction Queue(options) {\n  /**\n   * Queue options\n   *\n   * @type {Object}\n   * @private\n   */\n  var _options = (0, _lodash2.default)({\n    queue: {},\n    timer: 0,\n    timerDelay: 100,\n    replayTimer: 0,\n    replayTimerDelay: 100\n  }, options);\n\n  /**\n   * The batched queue tasks\n   * Queue actions are batched in an {Object} with a specific label\n   *\n   * @type {Object}\n   * @private\n   */\n  var _tasks = _options.queue;\n\n  /**\n   * The queue timer\n   * When the queue is added to, the timer is updated with a `setTimeout` call to the `run` function\n   *\n   * @type {Number}\n   * @private\n   */\n  var _timer = _options.timer;\n\n  /**\n   * The queue timer delay\n   * The delay between queue timer updates (in milliseconds)\n   *\n   * @type {Number}\n   * @default 100\n   * @private\n   */\n  var _timerDelay = _options.timerDelay;\n\n  /**\n   * The queue's replay timer which tracks if/when to fire queued actions while the queue is already running\n   */\n  var _replayTimer = _options.replayTimer || _options.timer;\n\n  /**\n   * The queue replay timer delay\n   * The delay between queue replay timer updates (in milliseconds)\n   *\n   * @type {number}\n   * @default 100\n   * @private\n   */\n  var _replayTimerDelay = _options.replayTimerDelay || _options.timerDelay;\n\n  /**\n   * The play status\n   * 0: paused\n   * 1: play\n   * 2: running\n   *\n   * @type {Number}\n   * @default 1\n   * @private\n   */\n  var _status = 1;\n\n  /**\n   * Check when queue has finished running to then replay the action\n   *\n   * @param {Queue} Q The queue to replay\n   * @param {String} actionName The action to replay\n   * @param {Mixed} ...args Any additional arguments to pass to the action\n   * @private\n   */\n  function _checkQueueFinished(Q) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var actionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'run';\n\n    // @debug\n    // console.log(`${__loggerPath} _checkQueueFinished`, {\n    //   actionName,\n    //   queue: Q\n    // })\n\n    clearTimeout(_replayTimer);\n\n    var checkQueueIsFinishedThenPerformAction = function checkQueueIsFinishedThenPerformAction() {\n      if (Q.checkStatus === 1 && Q.length() && Q.hasOwnProperty(actionName)) {\n        // @debug\n        // console.log(`[${__loggerPath}] Replaying queue...`, {\n        //   Queue: Q,\n        //   actionName,\n        //   args\n        // })\n\n        // Each action will either perform the action or replay itself if necessary\n        Q[actionName].apply(Q, args);\n      }\n    };\n\n    _replayTimer = setTimeout(checkQueueIsFinishedThenPerformAction, _replayTimerDelay);\n  }\n\n  /**\n   * @typedef {Object} Queue\n   */\n  var Queue = {\n    /**\n     * Queue an action\n     *\n     * @param {String} actionLabel A unique label for the action in the queue.\n     *                             Can be set to {undefined} (which means the action can't be removed)\n     * @param {Function} action The function to handle the action\n     * @param {Mixed} ...args The arguments to pass to the action handler\n     * @return {Self}\n     * @chainable\n     */\n    queue: function queue(actionLabel, action) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      // Default actionLabel is time value as string\n      if (!actionLabel) {\n        actionLabel = Date.now() + '';\n      }\n\n      // Assign the function to the queue\n      if (actionLabel && typeof action === 'function') {\n        _tasks[actionLabel] = {\n          action: action,\n          args: args\n        };\n      }\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Add action to the queue. After adding this will start the queue timer to then run the queue after the delay\n     *\n     * @param {String} actionLabel A unique label for the action in the queue.\n     *                             Can be set to {undefined} (which means the action can't be removed)\n     * @param {Function} action The function to handle the action\n     * @param {Mixed} ...args The arguments to pass to the action handler\n     * @return {Self}\n     * @chainable\n     */\n    add: function add(actionLabel, action) {\n      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      // @debug\n      // console.log(`[${__loggerPath}] add`, {\n      //   actionLabel,\n      //   action\n      // })\n\n      // Queue the action\n      this.queue.apply(this, [actionLabel, action].concat(_toConsumableArray(args)));\n\n      // Play the timer to get the queue to run after a delay (only when playing)\n      if (_status) {\n        this.play();\n      }\n      // } else {\n      //   // @debug\n      //   console.log(`[${__loggerPath}] add: queue is currently paused`)\n      // }\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Same as `add` except you can affect the delay time that the queue will play after adding the task.\n     *\n     * @param {Number} delay The milliseconds to delay before running the queue\n     * @param {String} actionLabel A unique label for the action in the queue.\n     *                             Can be set to {undefined} (which means the action can't be removed)\n     * @param {Function} action The function to handle the action\n     * @param {Mixed} [...args] The arguments to pass to the action handler\n     * @return {Self}\n     * @chainable\n     */\n    delayAdd: function delayAdd(delay, actionLabel, action) {\n      var _delay = delay || _timerDelay;\n\n      // @debug\n      // console.log(`[${__loggerPath}] delayAdd`, {\n      //   delay,\n      //   actionLabel,\n      //   action,\n      //   _delay,\n      //   _status\n      // })\n\n      // Queue the action\n\n      for (var _len4 = arguments.length, args = Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n        args[_key4 - 3] = arguments[_key4];\n      }\n\n      this.queue.apply(this, [actionLabel, action].concat(_toConsumableArray(args)));\n\n      // Play the timer to get the queue to run after a delay (only if already playing/running)\n      if (_status) {\n        this.play(_delay);\n      }\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Add action and then run the queue immediately.\n     *\n     * @param {String} actionLabel\n     * @param {Function} action\n     * @param {Mixed} actionArgs\n     * @return {Self}\n     * @chainable\n     */\n    sync: function sync(actionLabel, action) {\n      // @debug\n      // console.log(`[${__loggerPath}] sync`, {\n      //   actionLabel,\n      //   action\n      // })\n\n      // Ensure to clear the queue\n      clearTimeout(_timer);\n\n      // Queue action...\n\n      for (var _len5 = arguments.length, args = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n        args[_key5 - 2] = arguments[_key5];\n      }\n\n      this.queue.apply(this, [actionLabel, action].concat(_toConsumableArray(args)));\n\n      // ... Then run the queue immediately\n      this.run();\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Get the action by its label\n     *\n     * @param {String} actionLabel\n     * @return {undefined|Object}\n     */\n    getActionByLabel: function getActionByLabel(actionLabel) {\n      if (_tasks.hasOwnProperty(actionLabel)) {\n        return _tasks[actionLabel];\n      }\n\n      return undefined;\n    },\n\n\n    /**\n     * Remove action from queue. Can only remove actions if you know their label\n     *\n     * @param {String} actionLabel\n     * @return {Self}\n     * @chainable\n     */\n    remove: function remove(actionLabel) {\n      if (_tasks.hasOwnProperty(actionLabel)) {\n        // // @debug\n        // console.log(`[${__loggerPath}] task removed`, {\n        //   actionLabel\n        // })\n\n        _tasks[actionLabel] = undefined;\n        delete _tasks[actionLabel];\n      }\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Play the queue timer (will run queue after timer delay)\n     *\n     * @param {Number} [delay] The time in milliseconds before playing\n     * @return {Self}\n     * @chainable\n     */\n    play: function play(delay) {\n      var _this = this;\n\n      // Ensure delay is set properly (if someone sets to null or undefined it should default back to regular delay time)\n      var _delay = delay || _timerDelay;\n\n      // @debug\n      // if (delay) {\n      //   console.log(`[${__loggerPath}] play (with specified delay)`, {\n      //     delay,\n      //     _delay,\n      //     _status,\n      //     time\n      //   })\n      // }\n\n      // Currently already running\n      if (_status === 2) {\n        // @debug\n        // console.log(`[${__loggerPath}] queue is currently running, will perform 'play' next cycle`)\n\n        _checkQueueFinished.apply(undefined, [this, 'play'].concat(Array.prototype.slice.call(arguments)));\n        return;\n      }\n\n      // @debug\n      // console.log(`[${__loggerPath}] play`, {\n      //   delay,\n      //   _delay,\n      //   _status,\n      //   time\n      // })\n\n      clearTimeout(_timer);\n\n      // Set to playing\n      _status = 1;\n\n      // Reset timer to run the queue\n      var runQueueProcessAfterDelay = function runQueueProcessAfterDelay() {\n        // @debug\n        // console.log(`[${__loggerPath}] running queue after delay of ${_delay} (${delay}) ${time}`)\n\n        _this.run();\n      };\n      _timer = setTimeout(runQueueProcessAfterDelay, _delay);\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Pause the queue timer\n     *\n     * @return {Self}\n     * @chainable\n     */\n    pause: function pause() {\n      // Queue is already running\n      if (_status === 2) {\n        _checkQueueFinished(this, 'pause');\n        return;\n      }\n\n      // @debug\n      // console.log(`[${__loggerPath}] pause`, {\n      //   _status\n      // })\n\n      // Only pause if already playing\n      clearTimeout(_timer);\n\n      // Set to paused\n      _status = 0;\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Process/run all the actions in the queue\n     *\n     * @return {Self}\n     * @chainable\n     */\n    run: function run() {\n      // Currently already running, so run again later\n      if (_status === 2) {\n        _checkQueueFinished(this, 'run');\n        return;\n      }\n\n      // @debug\n      // console.log(`[${__loggerPath}] run`, {\n      //   _status,\n      //   _tasks\n      // })\n\n      clearTimeout(_timer);\n      clearTimeout(_replayTimer);\n\n      // No items in the queue, so force queue to pause\n      if (!Object.keys(_tasks).length) {\n        _status = 0;\n        return this;\n      }\n\n      // Save the queue's current status\n      var _previousStatus = _status;\n\n      // Set the status to running\n      _status = 2;\n\n      // @debug\n      // console.log(`[${__loggerPath}] run: processing...`, {\n      //   _previousStatus,\n      //   _status\n      // })\n\n      // Process the queue\n      for (var actionLabel in _tasks) {\n        if (_tasks.hasOwnProperty(actionLabel) && _tasks[actionLabel]) {\n          var queuedItem = _tasks[actionLabel];\n\n          // @debug\n          // console.log(`[${__loggerPath}] run --\x3e ${actionLabel}`, queuedItem)\n\n          // Function\n          if (queuedItem && typeof queuedItem === 'function') {\n            queuedItem();\n\n            // Object\n          } else if (queuedItem.hasOwnProperty('action') && typeof queuedItem.action === 'function') {\n            // Apply arguments to the action\n            if (queuedItem.hasOwnProperty('args') && queuedItem.args instanceof Array) {\n              queuedItem.action.apply(queuedItem, _toConsumableArray(queuedItem.args));\n\n              // Run the action like normal\n            } else {\n              queuedItem.action();\n            }\n          }\n\n          // Delete the queued item\n          _tasks[actionLabel] = undefined;\n          delete _tasks[actionLabel];\n        }\n      }\n\n      // Revert to status before run\n      _status = _previousStatus;\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Get the status of the queue:\n     *   0 = Paused\n     *   1 = Playing\n     *   2 = Running\n     * @return {Number}\n     */\n    checkStatus: function checkStatus() {\n      return _status;\n    },\n\n\n    /**\n     * Get the timer delay\n     *\n     * @return {Number}\n     */\n    getTimerDelay: function getTimerDelay() {\n      return _timerDelay;\n    },\n\n\n    /**\n     * Set the timer delay\n     *\n     * @param timerDelay\n     * @chainable\n     * @return {Self}\n     */\n    setTimerDelay: function setTimerDelay(timerDelay) {\n      // Only set if timerDelay is greater than 0\n      if (timerDelay && timerDelay > 0) {\n        _timerDelay = timerDelay;\n        _replayTimerDelay = timerDelay;\n      }\n\n      // @chainable\n      return this;\n    },\n\n\n    /**\n     * Get the length of the queue\n     *\n     * @return {Number}\n     */\n    length: function length() {\n      return Object.keys(_tasks).length;\n    },\n\n\n    /**\n     * Backward compatible alias\n     *\n     * @return {Queue.length}\n     */\n    getQueueLength: function getQueueLength() {\n      return this.length;\n    },\n\n\n    /**\n     * Get the queue tasks\n     *\n     * @return {Object}\n     */\n    getTasks: function getTasks() {\n      return _tasks;\n    },\n\n\n    /**\n     * Debug queue settings to the console\n     */\n    debug: function debug() {\n      console.log({\n        _options: _options,\n        _tasks: _tasks,\n        _timer: _timer,\n        _timerDelay: _timerDelay,\n        _replayTimer: _replayTimer,\n        _replayTimerDelay: _replayTimerDelay,\n        _status: _status,\n        Queue: this\n      });\n    }\n  };\n\n  return Queue;\n}\n\n//# sourceURL=webpack://lvl99/./es6/tools/queue.es6?")},"./es6/tools/smooth-scroll.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_SCROLLTO_OPTIONS = undefined;\nexports.isScrollable = isScrollable;\nexports.getScrollableParents = getScrollableParents;\nexports.getScrollToPosition = getScrollToPosition;\nexports.default = SmoothScroll;\n\nvar _common = __webpack_require__(/*! ../common */ \"./es6/common.es6\");\n\n/**\n * Default scrollTo options.\n *\n * @typedef {Object} ScrollToOptions\n *\n * @param {String|HTMLElement|jQueryObject} parent=\"html, body\"\n * The selector to match on the parent to be scrolled.\n *\n * @param {Number} bufferTop=0\n * The distance away from the the top of the parent to scroll to.\n *\n * @param {Number} scrollSpeed=1000\n * The total time in milliseconds to smoothly scroll. This will be relative to the distance, i.e. it will take a shorter\n * amount of time if the distance isn't that far.\n *\n * @param {Number} triggerDistance=200\n * The distance from the top that the target element must be from the top of the parent element.\n *\n * @param {Boolean} ignoreScrollingParents=true\n * Enable/disable scrolling parents to ensure the target is in view.\n */\nvar DEFAULT_SCROLLTO_OPTIONS = exports.DEFAULT_SCROLLTO_OPTIONS = {\n  // The space between the top of the window and the top of the target\n  bufferTop: 0,\n\n  // The speed to scroll the window\n  scrollSpeed: 1000,\n\n  // The distance from top of window to top of target element to trigger scrolling\n  triggerDistance: 200,\n\n  // Ignore scrolling scrollable parent elements\n  ignoreScrollingParents: false\n\n  /**\n   * Check if an element is scrollable.\n   *\n   * @param {String|HTMLElement|jQueryObject} elem\n   * @return {Boolean}\n   */\n}; /**\n    * # Smooth Scroll\n    *\n    * Smoothly scroll to internal anchor links on a page.\n    *\n    * ## Usage\n    *\n    * Smooth Scroll needs to be instantiated with jQuery and any configured options before using.\n    *\n    * ```\n    *   let SmoothScroll = require('lvl99/es6/tools/smooth-scroll')(jQuery, { bufferTop: 0 })\n    * ```\n    *\n    * You can also initialise the SmoothScroll behaviours by calling `SmoothScroll.init()`. This will attach the necessary\n    * events on to anchor links.\n    *\n    * You can trigger the scrollTo event by using the custom event `SmoothScroll.scrollTo`, e.g.:\n    *\n    * ```\n    *   $(document).trigger('SmoothScroll.scrollTo', [ scrollToOptions ])\n    * ```\n    *\n    * The `scrollTo` function emits a custom event `SmoothScroll.scrollTo:start` when the action is invoked and\n    * `SmoothScroll.scrollTo:end` when it finishes.\n    *\n    * @namespace lvl99.tools.SmoothScroll\n    * @requires module:jquery\n    */\n\nfunction isScrollable(elem) {\n  var $elem = (0, _common.$)(elem);\n  var hasLargerScrollableArea = $elem.outerHeight() > $elem[0].scrollHeight;\n  var isOverflowScrollable = $elem.css('overflow') === 'auto' || $elem.css('overflow') === 'scroll' || $elem.css('overflowX') === 'auto' || $elem.css('overflowX') === 'scroll' || $elem.css('overflowY') === 'auto' || $elem.css('overflowY') === 'scroll';\n  return $elem.length && /* hasLargerScrollableArea && */isOverflowScrollable;\n}\n\n/**\n * Get any scrollable parents of the target.\n *\n * This will go up the DOM tree and detect if any parent elements have an `overflow` value of `auto` or `scroll`.\n *\n * @param {String|HTMLElement|jQueryObject} target - The target element to get the scrollable parents for\n * @returns {Array}\n */\nfunction getScrollableParents(target) {\n  var $target = (0, _common.$)(target);\n  var scrollable = [];\n\n  // @debug\n  // console.log('[SmoothScroll] getScrollableParents', target)\n\n  $target.parents().not('html, body').each(function getEachScrollableParent(index, elem) {\n    if (isScrollable(elem)) {\n      scrollable.push(elem);\n    }\n  });\n\n  // Ensure the window is added last\n  scrollable.push(window);\n\n  // @debug\n  // console.log('[SmoothScroll] getScrollableParents', {\n  //   scrollable\n  // })\n\n  return scrollable.reverse();\n}\n\n/**\n * Get the parent's position to scroll to the intended target.\n *\n * @param {String|HTMLElement|jQueryObject} target\n * @param {String|HTMLElement|jQueryObject} [parent] - Will detect its scrollable parents or use the window if not set/falsey\n * @returns {{left: number, top: number}}\n */\nfunction getScrollToPosition(target, parent) {\n  var $target = (0, _common.$)(target).first();\n  var $parent = (0, _common.$)(parent || getScrollableParents(target) || window).first();\n  var targetPosition = $target.position();\n  var scrollTo = {\n    top: ($parent[0].scrollTop || 0) + targetPosition.top,\n    left: ($parent[0].scrollLeft || 0) + targetPosition.left\n  };\n\n  return scrollTo;\n}\n\n/**\n * SmoothScroll class\n *\n * @namespace lvl99.tools.SmoothScroll\n * @class\n * @param {ScrollToOptions} [scrollToOptions] - The options to pass to the SmoothScroll instance\n */\nfunction SmoothScroll(options) {\n  // Load in the settings\n  var settings = _common.$.extend({}, DEFAULT_SCROLLTO_OPTIONS, options);\n\n  /**\n   * Smoothly scroll to a target\n   *\n   * @memberof lvl99.tools.SmoothScroll\n   *\n   * @param {String|HTMLElement|jQueryObject} target\n   * @param {ScrollToOptions} scrollToOptions - The options to affect how the smooth scroll behaves\n   */\n  function scrollTo(target, scrollToOptions) {\n    // Load in per-use settings\n    var scrollToSettings = _common.$.extend({}, settings, scrollToOptions);\n    var scrollTargets = [];\n\n    // Figure out element to scroll to\n    var $target = (0, _common.$)(target).not('[data-disable-smooth-scroll]');\n\n    // More than one target, only use first\n    $target = $target.length > 1 ? $target.eq(0) : $target;\n\n    // No valid target found\n    if (!$target.length) {\n      return;\n    }\n\n    // Set the original target\n    scrollToSettings.originalTarget = $target[0];\n\n    // The top buffer\n    var bufferTop = typeof scrollToSettings.bufferTop === 'function' ? scrollToSettings.bufferTop.apply(this, [target, scrollToOptions]) : scrollToSettings.bufferTop || 0;\n\n    // Ensure that the parents will be scrolled to show the target as well\n    var scrollableParents = getScrollableParents($target);\n    if (!scrollToSettings.ignoreScrollableParents && scrollableParents && scrollableParents.length) {\n      scrollableParents.forEach(function (scrollableParent, index) {\n        var $elem = (0, _common.$)(scrollableParent);\n        var $nextTarget = (0, _common.$)(index === scrollableParents.length - 1 ? $target : scrollableParents[index + 1]);\n\n        // @debug\n        // console.log('generate scrollTarget', scrollTarget)\n\n        var scrollTarget = {\n          // Use the 'html,body' parent if it's the window\n          elem: _common.$.isWindow(scrollableParent) ? (0, _common.$)('html,body') : $elem,\n          target: $nextTarget,\n          scrollTo: getScrollToPosition($nextTarget, $elem)\n        };\n\n        scrollTargets.push(scrollTarget);\n      });\n\n      // Scroll only the window ('html,body' for jQuery.animate to work)\n    } else {\n      scrollTargets.push({\n        elem: (0, _common.$)('html,body'),\n        target: $target,\n        scrollTo: getScrollToPosition($target, window)\n      });\n    }\n\n    // @debug\n    // console.log('[SmoothScroll] scrollTo', scrollTargets)\n\n    // Do scroll targets exist?\n    if (scrollTargets && scrollTargets.length) {\n      /**\n       * Emit scrollTo:before event.\n       *\n       * Triggered on the target element being scrolled to.\n       *\n       * @event SmoothScroll#SmoothScroll.scrollTo:before\n       * @param {Array} scrollTargets\n       * @param {ScrollToOptions} scrollToSettings\n       */\n      $target.trigger('SmoothScroll.scrollTo:before', [scrollTargets, scrollToSettings]);\n\n      // Scroll each target\n      scrollTargets.forEach(function (scrollTarget) {\n        var $scrollTarget = (0, _common.$)(scrollTarget.elem);\n\n        /**\n         * Emit scrollTo:start event.\n         *\n         * Triggered on the element which is being scrolled, not the target being scrolled to.\n         *\n         * @event SmoothScroll#SmoothScroll.scrollTo:start\n         * @param {Array} scrollTarget\n         * @param {ScrollToOptions} scrollToSettings\n         */\n        $scrollTarget.trigger('SmoothScroll.scrollTo:start', [scrollTarget, scrollToSettings]);\n\n        // Doits!\n        $scrollTarget.animate({\n          scrollLeft: scrollTarget.scrollTo.left,\n          scrollTop: scrollTarget.scrollTo.top + bufferTop\n        }, scrollToSettings.scrollSpeed, function () {\n          // Only perform the following if pointing to the original target\n          if (scrollTarget.elem === scrollToSettings.originalTarget) {\n            // Callback after animation\n            // Must change focus!\n            $target.focus();\n\n            /**\n             * Emit `SmoothScroll.scrollTo:end` event.\n             *\n             * Triggered on the element which is being scrolled (not the target).\n             *\n             * @event SmoothScroll#SmoothScroll.scrollTo:end\n             * @param {Object} scrollTarget\n             * @param {ScrollToOptions} scrollToSettings\n             */\n            $scrollTarget.trigger('SmoothScroll.scrollTo:end', [scrollTarget, scrollToSettings]);\n\n            // Checking if the target was focused\n            if ($target.is(':focus')) {\n              return false;\n            }\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * Initialise all links on the page with the smoothScroll functionality\n   *\n   * @memberof lvl99.tools.SmoothScroll\n   */\n  function init() {\n    // Attach link behaviours\n    (0, _common.$)('a[href*=\"#\"]')\n    // Remove links that don't actually link to anything\n    .not('[href=\"#\"]').not('[href=\"#0\"]').click(function (event) {\n      var $a = (0, _common.$)(event.target).closest('a');\n      var hash = $a.attr('href').replace(/.*#([^?]+).*/, '#$1');\n      if ((0, _common.$)(hash).length > 0) {\n        event.preventDefault();\n        scrollTo(hash);\n      }\n    });\n\n    /**\n     * Trigger the scrollTo behaviour through the DOM\n     *\n     * ```javascript\n     *   $('#target-element').trigger('SmoothScroll.scrollTo')\n     * ```\n     *\n     * @event SmoothScroll#SmoothScroll.scrollTo\n     * @param {ScrollToOptions} options\n     */\n    (0, _common.$)(document).on('SmoothScroll.scrollTo', function (event) {\n      if (event.target) {\n        scrollTo(event.target, arguments.length <= 1 ? undefined : arguments[1]);\n      }\n    });\n\n    // Check to see if a hash is located in the window.location and scroll to the element\n    if (window.location.hash) {\n      setTimeout(function () {\n        scrollTo(window.location.hash);\n      }, 1000);\n    }\n  }\n\n  return {\n    settings: settings,\n    init: init,\n    scrollTo: scrollTo\n  };\n}\n\n//# sourceURL=webpack://lvl99/./es6/tools/smooth-scroll.es6?")},"./es6/tools/storage.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObjectStorage = exports.STORAGE_TYPES = exports.LOCAL_STORAGE = exports.SESSION_STORAGE = exports.OBJECT_STORAGE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LVL99 Storage\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Utilise modern browser features like localStorage and sessionStorage (if available within the environment)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @package lvl99\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nexports.testStorageType = testStorageType;\nexports.getSupportedStorageTypes = getSupportedStorageTypes;\nexports.eachStorageType = eachStorageType;\n\nvar _lodash = __webpack_require__(/*! lodash.merge */ \"./node_modules/lodash.merge/index.js\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _parse = __webpack_require__(/*! ../utils/parse */ \"./es6/utils/parse.es6\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Types of storage\nvar OBJECT_STORAGE = exports.OBJECT_STORAGE = 'objectStorage';\nvar SESSION_STORAGE = exports.SESSION_STORAGE = 'sessionStorage';\nvar LOCAL_STORAGE = exports.LOCAL_STORAGE = 'localStorage';\nvar STORAGE_TYPES = exports.STORAGE_TYPES = [OBJECT_STORAGE, SESSION_STORAGE, LOCAL_STORAGE];\n\n/**\n * Object Storage handler.\n *\n * This is a basic object-based fallback version of storage if local/session storage is not supported.\n *\n * It should work exactly the same as sessionStorage, however it is related only to the current window session --\n * data here is not persistent.\n *\n * @class\n */\n\nvar ObjectStorage = exports.ObjectStorage = function () {\n  /**\n   * Create the object storage instance.\n   *\n   * @constructor\n   * @param {Object} data\n   */\n  function ObjectStorage() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ObjectStorage);\n\n    this.data = data || {};\n  }\n\n  /**\n   * Clear all items in object storage.\n   *\n   * @returns {Object}\n   */\n\n\n  _createClass(ObjectStorage, [{\n    key: 'clear',\n    value: function clear() {\n      this.data = {};\n    }\n\n    /**\n     * Get item in object storage.\n     *\n     * @param {String} name\n     * @returns {*|null}\n     */\n\n  }, {\n    key: 'getItem',\n    value: function getItem(name) {\n      if (this.data.hasOwnProperty(name)) {\n        return this.data[name];\n      }\n      return null;\n    }\n\n    /**\n     * Set item in object storage.\n     *\n     * @param {String} name\n     * @param {*} value\n     */\n\n  }, {\n    key: 'setItem',\n    value: function setItem(name, value) {\n      this.data[name] = value;\n    }\n\n    /**\n     * Remove item in object storage.\n     *\n     * @param {String} name\n     */\n\n  }, {\n    key: 'removeItem',\n    value: function removeItem(name) {\n      if (this.data.hasOwnProperty(name)) {\n        this.data[name] = null;\n        delete this.data[name];\n      }\n    }\n  }]);\n\n  return ObjectStorage;\n}();\n\n// Create the objectStorage instance in the window\n\n\nwindow[OBJECT_STORAGE] = new ObjectStorage();\n\n/**\n * Test to see if a storage type works within the environment\n *\n * @param {String} storageType\n * @return {Boolean}\n */\nfunction testStorageType(storageType) {\n  try {\n    var envStorage = window[storageType];\n    var x = '__test__storage__';\n    envStorage.setItem(x, storageType);\n    envStorage.removeItem(x);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Get the supported types of storage\n *\n * @returns {Object} with name of storage type as keys with {Boolean} value\n */\nfunction getSupportedStorageTypes() {\n  var supports = {};\n\n  // Build the object from the constant's values\n  STORAGE_TYPES.forEach(function (storageType, index) {\n    supports[storageType] = testStorageType(storageType);\n  });\n\n  return supports;\n}\n\n/**\n * Perform a callback on each supported (or not) storage type\n *\n * @param {Function} cb\n */\nfunction eachStorageType(cb) {\n  var supported = getSupportedStorageTypes();\n\n  for (var storageType in supported) {\n    if (supported.hasOwnProperty(storageType)) {\n      cb.apply(this, [storageType, supported[storageType], supported]);\n    }\n  }\n}\n\n/**\n * Storage class\n */\n\nvar Storage = function () {\n  /**\n   * Create the storage class\n   *\n   * @param options\n   */\n  function Storage(options) {\n    _classCallCheck(this, Storage);\n\n    this.settings = (0, _lodash2.default)({\n      // default to localStorage\n      storageType: LOCAL_STORAGE\n    }, options);\n\n    // Test storageType to ensure it is supported. If not, default back to object storage\n    if (this.settings.storageType !== OBJECT_STORAGE && !testStorageType(this.settings.storageType)) {\n      this.settings.storageType = OBJECT_STORAGE;\n    }\n\n    return this;\n  }\n\n  /**\n   * Reset a single storage type\n   *\n   * @param storageType\n   */\n\n\n  _createClass(Storage, [{\n    key: 'clear',\n    value: function clear(storageType) {\n      // Use default storage type\n      if (!storageType) {\n        storageType = this.settings.storageType;\n      }\n\n      // Throw error\n      if (!testStorageType(storageType)) {\n        throw new Error('Storage type ' + storageType + ' not supported');\n      }\n\n      window[storageType].clear();\n    }\n\n    /**\n     * Reset all the data within all supported storage types\n     */\n\n  }, {\n    key: 'clearAll',\n    value: function clearAll() {\n      eachStorageType(function (storageType, isSupported) {\n        if (isSupported) {\n          window[storageType].clear();\n        }\n      });\n    }\n\n    /**\n     * Clear local storage\n     */\n\n  }, {\n    key: 'clearLocal',\n    value: function clearLocal() {\n      this.clear(LOCAL_STORAGE);\n    }\n\n    /**\n     * Clear session storage\n     */\n\n  }, {\n    key: 'clearSession',\n    value: function clearSession() {\n      this.clear(SESSION_STORAGE);\n    }\n\n    /**\n     * Get stored item's value by key from a specified storage type\n     *\n     * @param {String} name The name of the data to retrieve from storage\n     * @param {String} storageType The name of the storage type to retrieve from\n     * @returns {Mixed}\n     * @throws {Error}\n     */\n\n  }, {\n    key: 'getItem',\n    value: function getItem(name, storageType) {\n      // Use default storage type\n      if (!storageType) {\n        storageType = this.settings.storageType;\n      }\n\n      // Check if storage type is available\n      if (!testStorageType(storageType)) {\n        throw new Error('Storage type ' + storageType + ' not supported');\n      }\n\n      // Ensure value is coerced since storage stores as JSON/string\n      return (0, _parse.coerceToPrimitiveType)(window[storageType].getItem(name));\n    }\n\n    /**\n     * Get stored item's value by key from local storage\n     *\n     * @param {String} name The name of the data to retrieve from storage\n     * @returns {Mixed}\n     */\n\n  }, {\n    key: 'getItemLocal',\n    value: function getItemLocal(name) {\n      return this.getItem(name, LOCAL_STORAGE);\n    }\n\n    /**\n     * Get stored item's value by key from session storage\n     *\n     * @param {String} name The name of the item to retrieve from storage\n     * @returns {Mixed}\n     */\n\n  }, {\n    key: 'getItemSession',\n    value: function getItemSession(name) {\n      return this.getItem(name, SESSION_STORAGE);\n    }\n\n    /**\n     * Set an item's value in a specified storage type\n     *\n     * @param {String} name The name of the item to set in storage\n     * @param {Mixed} value\n     * @param {String} storageType\n     * @throws {Error}\n     */\n\n  }, {\n    key: 'setItem',\n    value: function setItem(name, value, storageType) {\n      // Use default storage type\n      if (!storageType) {\n        storageType = this.settings.storageType;\n      }\n\n      // Check if storage type is available\n      if (!testStorageType(storageType)) {\n        throw new Error('Storage type ' + storageType + ' not supported');\n      }\n\n      window[storageType].setItem(name, JSON.stringify(value));\n    }\n\n    /**\n     * Set an item's value in the local storage\n     *\n     * @param {String} name The name of the item to set in local storage\n     * @param {Mixed} value\n     */\n\n  }, {\n    key: 'setItemLocal',\n    value: function setItemLocal(name, value) {\n      this.setItem(name, value, LOCAL_STORAGE);\n    }\n\n    /**\n     * Set an item's value in the session storage\n     *\n     * @param {String} name The name of the item to set in session storage\n     * @param {Mixed} value\n     */\n\n  }, {\n    key: 'setItemSession',\n    value: function setItemSession(name, value) {\n      this.setItem(name, value, SESSION_STORAGE);\n    }\n\n    /**\n     * Remove an item from the default storage type\n     *\n     * @param {String} name The name of the item to remove from the storage type\n     * @param {String} storageType\n     * @throws {Error}\n     */\n\n  }, {\n    key: 'removeItem',\n    value: function removeItem(name, storageType) {\n      // Use default storage type\n      if (!storageType) {\n        storageType = this.settings.storageType;\n      }\n\n      // Check if storage type is available\n      if (!testStorageType(storageType)) {\n        throw new Error('Storage type ' + storageType + ' not supported');\n      }\n\n      window[storageType].removeItem(name);\n    }\n\n    /**\n     * Remove an item from local storage type\n     *\n     * @param {String} name The name of the item to remove from local storage\n     * @throws {Error}\n     */\n\n  }, {\n    key: 'removeItemLocal',\n    value: function removeItemLocal(name) {\n      this.removeItem(name, LOCAL_STORAGE);\n    }\n\n    /**\n     * Remove an item from session storage\n     *\n     * @param {String} name The name of the item to remove from session storage\n     * @throws {Error}\n     */\n\n  }, {\n    key: 'removeItemSession',\n    value: function removeItemSession(name) {\n      this.removeItem(name, SESSION_STORAGE);\n    }\n  }]);\n\n  return Storage;\n}();\n\nexports.default = Storage;\n\n//# sourceURL=webpack://lvl99/./es6/tools/storage.es6?")},"./es6/tools/trackevent.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = TrackEvent;\n\nvar _lodash = __webpack_require__(/*! lodash.merge */ \"./node_modules/lodash.merge/index.js\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _storage = __webpack_require__(/*! ./storage */ \"./es6/tools/storage.es6\");\n\nvar _storage2 = _interopRequireDefault(_storage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * LVL99 Track Event\n *\n * Caches tracked events until Google Analytics is loaded, then uploads to GA\n *\n * @module lvl99/tools/trackevent\n * @requires module:lodash.merge\n * @requires module:lvl99/tools/storage\n */\n\nvar __loggerPath = 'LVL99:TrackEvent';\n\n\n// Save events locally if GA isn't online\nvar STORAGE = new _storage2.default({\n  storageType: _storage.LOCAL_STORAGE\n});\nvar STORAGE_KEY = 'LVL99:TrackedEvents';\n\nfunction TrackEvent(debug, cb) {\n  var _this = this;\n\n  /**\n   * Detect if GA is loaded and then send any stored GA events\n   */\n  var attempts = 0;\n  var checkGALoaded = function checkGALoaded() {\n    attempts++;\n\n    if (debug && window.console && window.console.log) {\n      console.log('[' + __loggerPath + '] Checking for GA loaded... (#' + attempts + ')');\n    }\n\n    // Check if GA object is available\n    if (window.hasOwnProperty('ga') && window.ga && typeof window.ga === 'function') {\n      if (debug && window.console && window.console.log) {\n        console.log('[' + __loggerPath + '] --\x3e Found GA!');\n      }\n\n      // Fire the callback when GA is loaded\n      if (typeof cb === 'function') {\n        cb.call(_this);\n      }\n\n      // Send any saved events\n      var trackedEvents = STORAGE.getItem(STORAGE_KEY);\n      if (trackedEvents && trackedEvents.length > 0) {\n        if (debug && window.console && window.console.log) {\n          console.log('[' + __loggerPath + '] --\x3e Sending ' + trackedEvents.length + ' tracked events to GA', { trackedEvents: trackedEvents });\n        }\n\n        for (var index in trackedEvents) {\n          if (trackedEvents.hasOwnProperty(index)) {\n            window.ga('send', trackedEvents[index]);\n          }\n        }\n\n        // Clear the saved events\n        trackedEvents = [];\n        STORAGE.removeItem(STORAGE_KEY);\n      }\n\n      return;\n    }\n\n    // Cap attempts to detect GA\n    if (attempts >= 5) {\n      if (debug && window.console && window.console.log) {\n        console.warn('[' + __loggerPath + '] --\x3e Halted testing for GA to be loaded: maximum ' + attempts + ' attempts reached.');\n      }\n    } else {\n      if (debug && window.console && window.console.log) {\n        console.log('[' + __loggerPath + '] --\x3e GA not found... will try again');\n      }\n\n      _this.gaLoadedTimer = setTimeout(checkGALoaded, 5000);\n    }\n  };\n  this.gaLoadedTimer = setTimeout(checkGALoaded, 5000);\n\n  /**\n   * Track an event.\n   *\n   * @param {String} eventCategory\n   * @param {String} eventAction\n   * @param {String} eventLabel\n   * @param {Number} [eventValue]\n   * @param {Object} [fieldsObject]\n   */\n  this.track = function (eventCategory, eventAction, eventLabel, eventValue) {\n    var fieldsObject = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    var trackedEvent = (0, _lodash2.default)({\n      hitType: 'event',\n      eventCategory: eventCategory,\n      eventAction: eventAction,\n      eventLabel: eventLabel,\n      eventValue: eventValue\n    }, fieldsObject);\n\n    // GA is loaded\n    if (typeof window.ga !== 'undefined') {\n      if (debug && window.console && window.console.log) {\n        console.log('[' + __loggerPath + '] Send tracked event to GA', trackedEvent);\n      }\n\n      window.ga('send', trackedEvent);\n\n      // waiting for GA to load, use internal var to collect\n    } else {\n      if (debug && window.console && window.console.log) {\n        console.log('[' + __loggerPath + '] GA not loaded yet, caching tracked event...', trackedEvent);\n      }\n\n      var trackedEvents = STORAGE.getItem(STORAGE_KEY) || [];\n      trackedEvents.push(trackedEvent);\n      STORAGE.setItem(STORAGE_KEY, trackedEvents);\n    }\n  };\n}\n\n//# sourceURL=webpack://lvl99/./es6/tools/trackevent.es6?")},"./es6/utils/index.es6":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _parse = __webpack_require__(/*! ./parse */ "./es6/utils/parse.es6");\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nvar _inheritance = __webpack_require__(/*! ./inheritance */ "./es6/utils/inheritance.es6");\n\nvar _inheritance2 = _interopRequireDefault(_inheritance);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import super from \'./super\'\n\n/**\n * LVL99 Utils\n *\n * Utilities used throughout the framework\n *\n * @package lvl99\n */\n\nvar utils = {\n  parse: _parse2.default,\n  inheritance: _inheritance2.default\n};\n\nexports.default = utils;\n\n//# sourceURL=webpack://lvl99/./es6/utils/index.es6?')},"./es6/utils/inheritance.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exposeAllProperties = exposeAllProperties;\nexports.exposePrivateProperties = exposePrivateProperties;\nexports.createPublicGetProperty = createPublicGetProperty;\nexports.createPublicGetSetProperty = createPublicGetSetProperty;\n/**\n * LVL99 Inheritance utilities\n */\n\nvar RE_PRIVATE = /^_/;\n\n/**\n * Assign public getter/setter properties to the target. This will reference the target property (if it is set)\n * otherwise use the default property value. You can also whitelist the properties you want to selectively\n * expose by name.\n *\n * @param {Object|Function} target\n * @param {Object} defaultPropValues\n * @param {Array} whitelist\n */\nfunction exposeAllProperties(target, defaultPropValues, whitelist) {\n  var properties = void 0;\n\n  if (!target) {\n    throw new Error('No target was given');\n  }\n\n  // Filter non-whitelisted properties\n  properties = Object.keys(target).filter(function (item) {\n    return whitelist && whitelist.includes(item) || !whitelist;\n  });\n\n  // @debug\n  // console.log('filtered properties', properties)\n\n  if (!properties || !properties.length) {\n    throw new Error('No properties were given');\n  }\n\n  // Default prop values to target\n  if (typeof defaultPropValues === 'undefined') {\n    defaultPropValues = target;\n  }\n\n  // Process and expose the properties on the target\n  properties.forEach(function (propName) {\n    var usePropName = propName;\n\n    // Private values can only have a public getter\n    if (RE_PRIVATE.test(propName)) {\n      usePropName = propName.replace(RE_PRIVATE, '');\n\n      // @debug\n      // console.log('Found private property', {\n      //   propName,\n      //   usePropName,\n      //   propValue: defaultPropValues[propName],\n      //   target\n      // })\n\n      // Hide original private value\n      // Object.defineProperty(target, propName, {\n      //   enumerable: false\n      // })\n\n      // Create public interface\n      createPublicGetProperty(target, propName, usePropName, defaultPropValues[propName]);\n    } else {\n      // @debug\n      // console.log('Found public property', {\n      //   propName,\n      //   usePropName,\n      //   propValue: properties[propName],\n      //   target\n      // })\n\n      // Create public interface\n      createPublicGetSetProperty(target, propName, usePropName, defaultPropValues[propName]);\n    }\n  });\n}\n\n/**\n * Expose only the private properties listed on the target with public getter property. Whitelist only those you want\n * by adding the property's name to the whitelist {Array}\n *\n * @param {Object|Function} target\n * @param {Boolean|Object|Function} defaultPropValues\n * @param {Array} whitelist\n */\nfunction exposePrivateProperties(target) {\n  var defaultPropValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var whitelist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  var properties = void 0;\n\n  // Target is always required\n  if (!target) {\n    throw new Error('No target was given');\n  }\n\n  // Filter non-private or non-whitelisted properties\n  properties = Object.keys(target).filter(function (item) {\n    if (whitelist && whitelist.includes(item) || !whitelist || !whitelist.length) {\n      return RE_PRIVATE.test(item);\n    }\n    return false;\n  });\n\n  // @debug\n  // console.log('filtered properties', properties)\n\n  // Silent death\n  if (!properties.length) {\n    return;\n  }\n\n  // If default prop values not set, just use target properties\n  if (!defaultPropValues || defaultPropValues === undefined) {\n    defaultPropValues = target;\n  }\n\n  // Process and expose the properties on the target\n  properties.forEach(function (propName) {\n    var usePropName = propName;\n\n    // Create a public handle for the private property (removes the \"_\" at the start)\n    usePropName = propName.replace(RE_PRIVATE, '');\n\n    // Create public interface\n    createPublicGetProperty(target, propName, usePropName, defaultPropValues[propName]);\n  });\n}\n\n/**\n * Create a public getter interface for a property on a target\n *\n * @param {Object|Function} target\n * @param {String} targetPropName\n * @param {String} newPropName\n * @param {Mixed} defaultPropValue Used if the target's targetPropName is undefined\n */\nfunction createPublicGetProperty(target, targetPropName, newPropName, defaultPropValue) {\n  if (!target.hasOwnProperty(newPropName)) {\n    Object.defineProperty(target, newPropName, {\n      get: function get() {\n        return typeof target[targetPropName] !== 'undefined' ? target[targetPropName] : defaultPropValue;\n      },\n\n      set: undefined,\n      enumerable: true\n    });\n  }\n}\n\n/**\n * Create a public getter/setter interface for a property on a target\n *\n * @param {Object|Function} target\n * @param {String} targetPropName\n * @param {String} newPropName\n * @param {Mixed} defaultPropValue Used if the target's targetPropName is undefined\n */\nfunction createPublicGetSetProperty(target, targetPropName, newPropName, defaultPropValue) {\n  if (!target.hasOwnProperty(newPropName)) {\n    Object.defineProperty(target, newPropName, {\n      get: function get() {\n        return typeof target[targetPropName] !== 'undefined' ? target[targetPropName] : defaultPropValue;\n      },\n      set: function set(newValue) {\n        target[targetPropName] = newValue;\n      },\n\n      enumerable: true\n    });\n  }\n}\n\nvar inheritance = {\n  exposeAllProperties: exposeAllProperties,\n  exposePrivateProperties: exposePrivateProperties,\n  createPublicGetProperty: createPublicGetProperty,\n  createPublicGetSetProperty: createPublicGetSetProperty\n};\n\nexports.default = inheritance;\n\n//# sourceURL=webpack://lvl99/./es6/utils/inheritance.es6?")},"./es6/utils/parse.es6":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * LVL99 Parse\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * Parse strings or transform from one format to another\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @package lvl99\n                                                                                                                                                                                                                                                                               */\n\nexports.coerceToPrimitiveType = coerceToPrimitiveType;\nexports.convertToBoolean = convertToBoolean;\nexports.convertStringToJson = convertStringToJson;\nexports.convertStringToFloat = convertStringToFloat;\nexports.extractClassDetails = extractClassDetails;\nexports.extractTriggerDetails = extractTriggerDetails;\nexports.fixedEncodeURIComponent = fixedEncodeURIComponent;\nexports.getTargetBySelector = getTargetBySelector;\nexports.getTargetSelector = getTargetSelector;\nexports.extractTargetEventNames = extractTargetEventNames;\n\nvar _objectPath = __webpack_require__(/*! object-path */ \"./node_modules/object-path/index.js\");\n\nvar _objectPath2 = _interopRequireDefault(_objectPath);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __loggerPath = 'lvl99/utils/parse';\n\n/**\n * Coerce a value to its primitive type\n *\n * @param {Mixed} input\n * @returns {Mixed}\n */\nfunction coerceToPrimitiveType(input) {\n  // Non-string or empty string? Just return it straight away\n  if (typeof input !== 'string' || input === '') {\n    return input;\n  }\n\n  // Trim any whitespace\n  var output = (input + '').trim();\n\n  // Number\n  if (/^\\-?(?:\\d*[\\.\\,])*\\d*(?:[eE](?:\\-?\\d+)?)?$/.test(input)) {\n    return parseFloat(input);\n\n    // Boolean: true\n  } else if (/^(true|1)$/.test(input)) {\n    return true;\n\n    // NaN\n  } else if (/^NaN$/.test(input)) {\n    return NaN;\n\n    // undefined\n  } else if (/^undefined$/.test(input)) {\n    return undefined;\n\n    // null\n  } else if (/^null$/.test(input)) {\n    return null;\n\n    // Boolean: false\n  } else if (/^(false|0)$/.test(input) || input === '') {\n    return false;\n\n    // JSON: starts with [ or { and ends with ] or }\n  } else if (/^[\\[\\{]/.test(input) && /[\\]\\}]$/.test(input)) {\n    return convertStringToJson(input);\n\n    // String marked with single/double quotation marks\n  } else if (/^['\"]|[\"']$/) {\n    return input.replace(/^['\"]|['\"]$/g, '');\n  }\n\n  // Default to string\n  return input;\n}\n\n/**\n * Convert value to an explicit boolean. Namely for processing string values.\n *\n * @param {Mixed} input\n * @returns {Boolean}\n */\nfunction convertToBoolean(input) {\n  // Already boolean\n  if (input === true || input === false) {\n    return input;\n  }\n\n  // Cases of truthy/falsey values\n  switch (input) {\n    case 1:\n    case '1':\n    case 'true':\n      return true;\n\n    case 0:\n    case '0':\n    case 'false':\n    case undefined:\n    case 'undefined':\n    case null:\n    case 'null':\n    case NaN:\n    case 'NaN':\n    case '':\n      return false;\n  }\n\n  // Otherwise...\n  return !!input;\n}\n\n/**\n * Convert a string to JSON or just return the string if can't\n *\n * @param {String} input\n * @returns {Object}\n */\nfunction convertStringToJson(input) {\n  var output = input;\n\n  // Convert string data to JSON\n  if (typeof input === 'string') {\n    try {\n      output = JSON.parse(input);\n    } catch (e) {\n      console.error(__loggerPath + '.convertStringToJson: Error parsing string JSON data', input);\n    }\n  }\n\n  return output;\n}\n\n/**\n * Convert a string to a float.\n * This also converts number constants like Infinity and NaN to zero.\n *\n * @param input\n * @returns {*}\n */\nfunction convertStringToFloat(input) {\n  if (typeof input === 'number') {\n    return input;\n  }\n\n  var output = parseFloat((input + '').replace(/[^\\d\\-\\.]+/g, ''));\n\n  // Infinity / NaN\n  if (!isFinite(input) || isNaN(input) || isNaN(output)) {\n    output = 0;\n  }\n\n  return output;\n}\n\n/**\n * Extract key-values from a string which is like a CSS class declaration, e.g. `key: value; key: value`\n *\n * This is slightly more interesting as it can take a name with dots\n *\n * @param {String} input\n * @return {Object}\n */\nfunction extractClassDetails(input) {\n  var output = {};\n  var inputParts = [input];\n\n  // Check if it has semi-colons\n  if (/;/.test(input)) {\n    inputParts = input.split(';');\n  }\n\n  // Process each input part\n  inputParts.forEach(function (part) {\n    part = part.trim();\n    if (part) {\n      var partParts = part.match(/([a-z0-9_.-]+):([^;]+);?/i);\n      var partName = partParts[1].trim();\n      var partValue = coerceToPrimitiveType(partParts[2].trim());\n\n      // @debug\n      // console.log('parsed part', {\n      //   part,\n      //   partName,\n      //   partValue,\n      // })\n\n      // Ensure output object exists if using dot notation\n      if (/\\./.test(partName)) {\n        var objParts = partName.split('.');\n        var objPartPath = '';\n\n        // @debug\n        // console.log('part has dot notation', {\n        //   output,\n        //   partName,\n        //   partValue,\n        //   objParts,\n        //   objPartPath\n        // })\n\n        for (var objPartIndex = 0; objPartIndex < objParts.length - 1; objPartIndex++) {\n          objPartPath += (objPartIndex > 0 ? '.' : '') + objParts[objPartIndex];\n\n          // @debug\n          // console.log(objPartPath)\n\n          if (!_objectPath2.default.has(output, objPartPath)) {\n            // @debug\n            // console.log('setting object part path', {\n            //   output,\n            //   partName,\n            //   partValue,\n            //   objPartIndex,\n            //   objPartPath\n            // })\n\n            _objectPath2.default.set(output, objPartPath, {});\n          }\n        }\n      }\n\n      // Set via objectPath\n      _objectPath2.default.set(output, partName, partValue);\n    }\n  });\n\n  return output;\n}\n\n/**\n * Extract the trigger's target details\n *\n * This allows you to extract the necessary data from the string and the global window/document available, to create\n * dynamic event bindings.\n *\n * @param {String|Object} input\n * @param {Object|Function} context Defaults to `window`. Where to find the `do` action\n * @returns {Object} => { eventName: {String}, method: {Function}, selector: {String}, target: {Object} }\n */\nfunction extractTriggerDetails(input, context) {\n  var trigger = input;\n\n  if (!context) {\n    context = window;\n  }\n\n  // String input given\n  if (typeof input === 'string') {\n    // Try JSON first\n    if (/^{/.test(input)) {\n      trigger = convertStringToJson(input);\n\n      // Try class details\n    } else if (/^[a-z0-9_-]+:/.test(input)) {\n      trigger = extractClassDetails(input);\n\n      // String with no spaces\n    } else if (!/ /.test(input)) {\n      trigger = {\n        do: input\n      };\n    }\n  }\n\n  // No object found!\n  if ((typeof trigger === 'undefined' ? 'undefined' : _typeof(trigger)) !== 'object') {\n    throw new Error(__loggerPath + '.extractTriggerDetails: input was not valid JSON or CSS-style definition');\n  }\n\n  // Ensure it has `on` and `do` properties\n  // if (!objectPath.has(trigger, 'on')) {\n  //   throw new Error(`${__loggerPath}.extractTriggerDetails: trigger is missing required 'on' property`)\n  // }\n  if (!_objectPath2.default.has(trigger, 'do')) {\n    throw new Error(__loggerPath + '.extractTriggerDetails: trigger is missing required \\'do\\' property');\n  }\n\n  // If target is set, use real values for window and document\n  if (_objectPath2.default.has(trigger, 'target')) {\n    switch (trigger.target) {\n      case 'self':\n        // console.log('Targeting self', context)\n        trigger.target = context;\n        break;\n\n      case 'document':\n        trigger.target = document;\n        break;\n\n      case 'window':\n        trigger.target = window;\n        break;\n    }\n  }\n\n  // Do same as above if a context was set!\n  if (_objectPath2.default.has(trigger, 'context')) {\n    switch (trigger.context) {\n      case 'document':\n        trigger.context = document;\n        break;\n\n      case 'window':\n        trigger.context = window;\n        break;\n    }\n  } else {\n    trigger.context = context;\n  }\n\n  return trigger;\n}\n\n/**\n * Encode string to URL, with spaces that are represented as `+`\n * See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n *\n * @param {String} input\n * @returns {String}\n */\nfunction fixedEncodeURIComponent(input) {\n  return encodeURIComponent(input).replace(/[!'()*]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16);\n  });\n}\n\n/**\n * Get the target object by a string selector\n *\n * @param {String} target\n * @param {Object} context\n * @return {Object}\n */\nfunction getTargetBySelector(target, context) {\n  // Default to document\n  if (!target) {\n    target = document;\n  }\n\n  if (typeof target === 'string') {\n    // Special string values to get the actual object\n    switch (target) {\n      case 'document':\n        target = document;\n        break;\n\n      case 'window':\n        target = window;\n        break;\n\n      case 'self':\n        target = context;\n        break;\n    }\n  }\n\n  return target;\n}\n\n/**\n * Get the target object's string selector\n *\n * @param {Object} target\n * @param {Object} context\n * @return {undefined|String}\n */\nfunction getTargetSelector(target, context) {\n  if (typeof target === 'string') {\n    return target;\n  }\n\n  // Window\n  if ($.isWindow(target)) {\n    return 'window';\n\n    // Document\n  } else if (target === document) {\n    return 'document';\n\n    // Self\n  } else if (target.hasOwnProperty('uuid')) {\n    return '[data-component-id=\"' + target.uuid + '\"]';\n\n    // HTML Elem\n  } else if ($(target).length) {\n    if ($(target).attr('data-component-id')) {\n      return '[data-component-id=\"' + $(target).attr('data-component-id') + '\"]';\n    } else if ($(target).attr('id')) {\n      return '#' + $(target).attr('id');\n    } else {\n      return '' + target.tagName.toLowerCase();\n    }\n  }\n\n  return target;\n}\n\n/**\n * Parse the target event names\n *\n * @param {Array|String} eventNames e.g. `Component:customEvent dom:mouseover`\n * @param {String} namespace Optional namespace to assign each extracted custom (non-DOM) event name\n * @returns {Array}\n */\nfunction extractTargetEventNames(inputEventNames, namespace) {\n  var targetEventNames = [];\n  var eventNames = inputEventNames;\n\n  if (typeof inputEventNames === 'string') {\n    // Split eventNames by spaces\n    if (/\\s/.test(inputEventNames)) {\n      eventNames = inputEventNames.split(/\\s+/);\n    } else {\n      eventNames = [inputEventNames];\n    }\n  }\n\n  if (eventNames instanceof Array) {\n    // Process each event name\n    eventNames.forEach(function (eventName) {\n      // Default to namespaced event name\n      var targetEventName = typeof namespace === 'string' && namespace !== '' ? namespace + ':' + eventName : eventName;\n\n      // Remove any reference to the native DOM event namespace\n      if (/^dom:/i.test(eventName)) {\n        targetEventName = eventName.replace(/^dom\\:/gi, '', eventName);\n      }\n\n      // Add to the list\n      targetEventNames.push(targetEventName);\n    });\n\n    return targetEventNames;\n  }\n\n  return false;\n}\n\nvar parse = {\n  coerceToPrimitiveType: coerceToPrimitiveType,\n  convertToBoolean: convertToBoolean,\n  convertStringToJson: convertStringToJson,\n  convertStringToFloat: convertStringToFloat,\n  extractClassDetails: extractClassDetails,\n  extractTriggerDetails: extractTriggerDetails,\n  fixedEncodeURIComponent: fixedEncodeURIComponent,\n  getTargetBySelector: getTargetBySelector,\n  getTargetSelector: getTargetSelector,\n  extractTargetEventNames: extractTargetEventNames\n};\n\nexports.default = parse;\n\n//# sourceURL=webpack://lvl99/./es6/utils/parse.es6?")},"./node_modules/lodash.merge/index.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (typeof key == 'number' && value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  if (!(isArray(source) || isTypedArray(source))) {\n    var props = baseKeysIn(source);\n  }\n  arrayEach(props || source, function(srcValue, key) {\n    if (props) {\n      key = srcValue;\n      srcValue = source[key];\n    }\n    if (isObject(srcValue)) {\n      stack || (stack = new Stack);\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(object[key], srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  });\n}\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = object[key],\n      srcValue = source[key],\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    newValue = srcValue;\n    if (isArray(srcValue) || isTypedArray(srcValue)) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else {\n        isCommon = false;\n        newValue = baseClone(srcValue, true);\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {\n        isCommon = false;\n        newValue = baseClone(srcValue, true);\n      }\n      else {\n        newValue = objValue;\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) ||\n      objectToString.call(value) != objectTag || isHostObject(value)) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = merge;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://lvl99/./node_modules/lodash.merge/index.js?")},"./node_modules/object-path/index.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function(){\n  'use strict';\n\n  var toStr = Object.prototype.toString;\n  function hasOwnProperty(obj, prop) {\n    if(obj == null) {\n      return false\n    }\n    //to handle objects with null prototypes (too edge case?)\n    return Object.prototype.hasOwnProperty.call(obj, prop)\n  }\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (typeof value !== 'string') {\n        for (var i in value) {\n            if (hasOwnProperty(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  var isArray = Array.isArray || function(obj){\n    /*istanbul ignore next:cant test*/\n    return toStr.call(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function factory(options) {\n    options = options || {}\n\n    var objectPath = function(obj) {\n      return Object.keys(objectPath).reduce(function(proxy, prop) {\n        if(prop === 'create') {\n          return proxy;\n        }\n\n        /*istanbul ignore else*/\n        if (typeof objectPath[prop] === 'function') {\n          proxy[prop] = objectPath[prop].bind(objectPath, obj);\n        }\n\n        return proxy;\n      }, {});\n    };\n\n    function hasShallowProperty(obj, prop) {\n      return (options.includeInheritedProps || (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop))\n    }\n\n    function getShallowProperty(obj, prop) {\n      if (hasShallowProperty(obj, prop)) {\n        return obj[prop];\n      }\n    }\n\n    function set(obj, path, value, doNotReplace){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (typeof path === 'string') {\n        return set(obj, path.split('.').map(getKey), value, doNotReplace);\n      }\n      var currentPath = path[0];\n      var currentValue = getShallowProperty(obj, currentPath);\n      if (path.length === 1) {\n        if (currentValue === void 0 || !doNotReplace) {\n          obj[currentPath] = value;\n        }\n        return currentValue;\n      }\n\n      if (currentValue === void 0) {\n        //check if we assume an array\n        if(typeof path[1] === 'number') {\n          obj[currentPath] = [];\n        } else {\n          obj[currentPath] = {};\n        }\n      }\n\n      return set(obj[currentPath], path.slice(1), value, doNotReplace);\n    }\n\n    objectPath.has = function (obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      } else if (typeof path === 'string') {\n        path = path.split('.');\n      }\n\n      if (!path || path.length === 0) {\n        return !!obj;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        var j = getKey(path[i]);\n\n        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||\n          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {\n          obj = obj[j];\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    objectPath.ensureExists = function (obj, path, value){\n      return set(obj, path, value, true);\n    };\n\n    objectPath.set = function (obj, path, value, doNotReplace){\n      return set(obj, path, value, doNotReplace);\n    };\n\n    objectPath.insert = function (obj, path, value, at){\n      var arr = objectPath.get(obj, path);\n      at = ~~at;\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n      arr.splice(at, 0, value);\n    };\n\n    objectPath.empty = function(obj, path) {\n      if (isEmpty(path)) {\n        return void 0;\n      }\n      if (obj == null) {\n        return void 0;\n      }\n\n      var value, i;\n      if (!(value = objectPath.get(obj, path))) {\n        return void 0;\n      }\n\n      if (typeof value === 'string') {\n        return objectPath.set(obj, path, '');\n      } else if (isBoolean(value)) {\n        return objectPath.set(obj, path, false);\n      } else if (typeof value === 'number') {\n        return objectPath.set(obj, path, 0);\n      } else if (isArray(value)) {\n        value.length = 0;\n      } else if (isObject(value)) {\n        for (i in value) {\n          if (hasShallowProperty(value, i)) {\n            delete value[i];\n          }\n        }\n      } else {\n        return objectPath.set(obj, path, null);\n      }\n    };\n\n    objectPath.push = function (obj, path /*, values */){\n      var arr = objectPath.get(obj, path);\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n\n      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n    };\n\n    objectPath.coalesce = function (obj, paths, defaultValue) {\n      var value;\n\n      for (var i = 0, len = paths.length; i < len; i++) {\n        if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n          return value;\n        }\n      }\n\n      return defaultValue;\n    };\n\n    objectPath.get = function (obj, path, defaultValue){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (obj == null) {\n        return defaultValue;\n      }\n      if (typeof path === 'string') {\n        return objectPath.get(obj, path.split('.'), defaultValue);\n      }\n\n      var currentPath = getKey(path[0]);\n      var nextObj = getShallowProperty(obj, currentPath)\n      if (nextObj === void 0) {\n        return defaultValue;\n      }\n\n      if (path.length === 1) {\n        return nextObj;\n      }\n\n      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n    };\n\n    objectPath.del = function del(obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      }\n\n      if (obj == null) {\n        return obj;\n      }\n\n      if (isEmpty(path)) {\n        return obj;\n      }\n      if(typeof path === 'string') {\n        return objectPath.del(obj, path.split('.'));\n      }\n\n      var currentPath = getKey(path[0]);\n      if (!hasShallowProperty(obj, currentPath)) {\n        return obj;\n      }\n\n      if(path.length === 1) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      } else {\n        return objectPath.del(obj[currentPath], path.slice(1));\n      }\n\n      return obj;\n    }\n\n    return objectPath;\n  }\n\n  var mod = factory();\n  mod.create = factory;\n  mod.withInheritedProps = factory({includeInheritedProps: true})\n  return mod;\n});\n\n\n//# sourceURL=webpack://lvl99/./node_modules/object-path/index.js?")},"./node_modules/uuid/index.js":function(module,exports,__webpack_require__){eval('var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");\nvar v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n//# sourceURL=webpack://lvl99/./node_modules/uuid/index.js?')},"./node_modules/uuid/lib/bytesToUuid.js":function(module,exports){eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n//# sourceURL=webpack://lvl99/./node_modules/uuid/lib/bytesToUuid.js?")},"./node_modules/uuid/lib/rng-browser.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It\'s fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack://lvl99/./node_modules/uuid/lib/rng-browser.js?')},"./node_modules/uuid/v1.js":function(module,exports,__webpack_require__){eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n//# sourceURL=webpack://lvl99/./node_modules/uuid/v1.js?")},"./node_modules/uuid/v4.js":function(module,exports,__webpack_require__){eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n//# sourceURL=webpack://lvl99/./node_modules/uuid/v4.js?")},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1, eval)("this");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === "object") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack://lvl99/(webpack)/buildin/global.js?')},"./node_modules/webpack/buildin/module.js":function(module,exports){eval('module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, "loaded", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, "id", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack://lvl99/(webpack)/buildin/module.js?')},jquery:function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;\n\n//# sourceURL=webpack://lvl99/external_%22jQuery%22?")}})});